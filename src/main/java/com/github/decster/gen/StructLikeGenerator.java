/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS
 * either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package com.github.decster.gen;

import com.github.decster.ast.DocumentNode;
import com.github.decster.ast.ExceptionNode;
import com.github.decster.ast.FieldNode;
import com.github.decster.ast.Node;
import com.github.decster.ast.StructLikeNode;
import com.github.decster.ast.TypeAnnotationNode;
import com.github.decster.ast.TypeNode;
import com.github.decster.ast.BaseTypeNode;
import com.github.decster.ast.MapTypeNode;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/**
 * Generator for Thrift structs that produces Java code.
 * This class mirrors the functionality of the C++ implementation
 * in t_java_generator.cc
 */
public class StructLikeGenerator {

    // Configuration options
    private boolean beanStyle;
    private boolean privateMembers;
    private boolean androidStyle;
    private boolean androidLegacy;
    private boolean sortedContainers;
    private boolean java5;
    private boolean useOptionType;
    private boolean useJdk8OptionType;
    private boolean undatedGeneratedAnnotations;
    private boolean suppressGeneratedAnnotations;
    private boolean unsafeBinaries;
    private boolean jakartaAnnotations;

    private StructLikeNode structLikeNode;
    private DocumentNode documentNode;
    private String packageName;
    private String date;
    private StringBuilder out;

    private int indentLevel = 0;
    private int tempVarCounter = 0; // For generating unique temporary variable names


    public StructLikeGenerator(StructLikeNode structLikeNode, DocumentNode documentNode, String packageName, String date, Map<String, Boolean> options) {
        this.structLikeNode = structLikeNode;
        this.documentNode = documentNode;
        this.packageName = packageName;
        this.date = date;
        this.out = new StringBuilder();

        this.beanStyle = options.getOrDefault("bean_style", false);
        this.privateMembers = options.getOrDefault("private_members", false);
        this.androidStyle = options.getOrDefault("android_style", false);
        this.androidLegacy = options.getOrDefault("android_legacy", false);
        this.sortedContainers = options.getOrDefault("sorted_containers", false);
        this.java5 = options.getOrDefault("java5", false);
        this.useOptionType = options.getOrDefault("use_option_type", false);
        this.useJdk8OptionType = options.getOrDefault("use_jdk8_option_type", false);
        this.undatedGeneratedAnnotations = options.getOrDefault("undated_generated_annotations", false);
        this.suppressGeneratedAnnotations = options.getOrDefault("suppress_generated_annotations", false);
        this.unsafeBinaries = options.getOrDefault("unsafe_binaries", false);
        this.jakartaAnnotations = options.getOrDefault("jakarta_annotations", false);

        if (java5) {
            this.androidLegacy = true;
        }
    }

    private String getNextTempVarName(String prefix) {
        return prefix + (tempVarCounter++);
    }

    public String generate() {
        this.tempVarCounter = 0; // Reset for each generation run
        out.append("/**\n");
        out.append(" * Autogenerated by Thrift Compiler (0.20.0)\n");
        out.append(" *\n");
        out.append(" * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n");
        out.append(" *  @generated\n");
        out.append(" */\n");
        out.append("package ").append(packageName).append(";\n\n");

        boolean needsBitSetImport = false;
        if (structLikeNode != null && structLikeNode.getFields() != null && !structLikeNode.getFields().isEmpty()) {
             int fieldCountForIsset = getIssetHandledFieldCount();
             IssetType issetStorageType = determineIssetStorageType(fieldCountForIsset);
            if (issetStorageType == IssetType.BITSET) {
                needsBitSetImport = true;
            }
        }
        if (needsBitSetImport) {
            out.append("import java.util.BitSet;\n");
        }

        generateStructDefinition(structLikeNode, structLikeNode instanceof ExceptionNode, false, false);
        return out.toString();
    }

    private void generateStructDefinition(StructLikeNode struct, boolean isException, boolean inClass, boolean isResult) {
        generateJavaDoc(struct);
        out.append(indent()).append(getJavaSuppressWarnings()).append("\n");

        boolean isStructFinal = isFinal(struct);
        boolean isStructDeprecated = isDeprecated(struct);

        if (!inClass && !suppressGeneratedAnnotations) {
            generateJavaxGeneratedAnnotation();
        }

        if (isStructDeprecated) {
            out.append(indent()).append("@Deprecated\n");
        }

        out.append(indent()).append("public ").append(isStructFinal ? "final " : "").append(inClass ? "static " : "")
                .append("class ").append(getEffectiveJavaIdentifier(struct.getName())).append(" ");

        if (isException) {
            out.append("extends org.apache.thrift.TException ");
        }

        String structJavaName = getEffectiveJavaIdentifier(struct.getName());
        out.append("implements org.apache.thrift.TBase<")
                .append(structJavaName).append(", ")
                .append(structJavaName)
                .append("._Fields>, java.io.Serializable, Cloneable, Comparable<")
                .append(structJavaName).append(">");

        if (androidStyle) {
            out.append(", android.os.Parcelable");
        }
        out.append(" {\n");
        indentLevel++;

        generateStructDesc(struct);
        out.append("\n");
        generateFieldDescs(struct);
        out.append("\n");
        generateSchemeMap(struct);
        out.append("\n");
        generateMemberFields(struct);
        out.append("\n");

        if (androidStyle) {
            generateJavaStructParcelable(struct);
            out.append("\n");
        }

        generateFieldNameConstants(struct);
        out.append("\n");
        generateIssetDefinitions(struct);
        generateJavaMetaDataMap(struct);
        generateConstructors(struct);
        generateClearMethod(struct);
        generateGettersAndSetters(struct);
        generateSetFieldValueMethod(struct);
        generateGetFieldValueMethod(struct);
        generateIsSetFieldMethod(struct);
        generateJavaStructEquality(struct);
        generateJavaStructCompareTo(struct);
        generateJavaStructFieldById(struct);
        generateJavaStructReader(struct);
        if (isResult) {
            generateJavaStructResultWriter(struct);
        } else {
            generateJavaStructWriter(struct);
        }
        generateJavaStructToString(struct);
        generateJavaValidator(struct);
        generateJavaStructWriteObject(struct);
        generateJavaStructReadObject(struct);
        generateJavaStructStandardScheme(struct, isResult);
        generateJavaStructTupleScheme(struct);
        generateJavaSchemeLookup();

        indentLevel--;
        out.append(indent()).append("}\n");
    }

    private String getEffectiveJavaIdentifier(String originalName) {
        return makeValidJavaIdentifier(originalName);
    }

    private void generateStructDesc(StructLikeNode struct) {
        out.append(indent()).append("private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new ")
                .append("org.apache.thrift.protocol.TStruct(\"")
                .append(struct.getName()).append("\");\n");
    }

    private void generateFieldDescs(StructLikeNode struct) {
        for (FieldNode field : struct.getFields()) {
            String originalFieldName = field.getName();
            TypeNode fieldType = field.getType();

            out.append(indent()).append("private static final org.apache.thrift.protocol.TField ")
                    .append(constantName(originalFieldName).toUpperCase())
                    .append("_FIELD_DESC = new org.apache.thrift.protocol.TField(\"")
                    .append(originalFieldName)
                    .append("\", ").append(typeToEnum(fieldType))
                    .append(", (short)").append(field.getId()).append(");\n");
        }
    }

    private void generateSchemeMap(StructLikeNode struct) {
        out.append(indent()).append("private static final org.apache.thrift.scheme.SchemeFactory ")
                .append("STANDARD_SCHEME_FACTORY = new ")
                .append(getEffectiveJavaIdentifier(struct.getName())).append("StandardSchemeFactory();\n");

        out.append(indent()).append("private static final org.apache.thrift.scheme.SchemeFactory ")
                .append("TUPLE_SCHEME_FACTORY = new ")
                .append(getEffectiveJavaIdentifier(struct.getName())).append("TupleSchemeFactory();\n");
    }

    private void generateMemberFields(StructLikeNode struct) {
        for (FieldNode field : struct.getFields()) {
            if (beanStyle || privateMembers) {
                out.append(indent()).append("private ");
            } else {
                generateJavaDoc(field);
                out.append(indent()).append("public ");
            }
            out.append(declareField(field, false, true)).append("\n");
        }
    }

    private void generateFieldNameConstants(StructLikeNode struct) {
        out.append(indent()).append("/** The set of fields this struct contains, along with convenience methods for ")
                .append("finding and manipulating them. */\n");

        out.append(indent()).append("public enum _Fields implements org.apache.thrift.TFieldIdEnum {\n");
        indentLevel++;

        boolean first = true;
        for (FieldNode field : struct.getFields()) {
            if (!first) {
                out.append(",\n");
            }
            first = false;

            generateJavaDoc(field);
            String originalFieldName = field.getName();
            out.append(indent()).append(constantName(originalFieldName).toUpperCase())
                    .append("((short)").append(field.getId())
                    .append(", \"").append(originalFieldName).append("\")");
        }

        out.append(";\n\n");

        out.append(indent()).append("private static final java.util.Map<java.lang.String, _Fields> byName = new ")
                .append("java.util.HashMap<java.lang.String, _Fields>();\n\n");

        out.append(indent()).append("static {\n");
        indentLevel++;
        out.append(indent()).append("for (_Fields field : java.util.EnumSet.allOf(_Fields.class)) {\n");
        indentLevel++;
        out.append(indent()).append("byName.put(field.getFieldName(), field);\n");
        indentLevel--;
        out.append(indent()).append("}\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");

        out.append(indent()).append("/**\n");
        out.append(indent()).append(" * Find the _Fields constant that matches fieldId, or null if its not found.\n");
        out.append(indent()).append(" */\n");
        out.append(indent()).append(javaNullableAnnotation()).append("\n");
        out.append(indent()).append("public static _Fields findByThriftId(int fieldId) {\n");
        indentLevel++;
        out.append(indent()).append("switch(fieldId) {\n");
        indentLevel++;
        for (FieldNode field : struct.getFields()) {
            String originalFieldName = field.getName();
            out.append(indent()).append("case ").append(field.getId()).append(": // ")
                    .append(constantName(originalFieldName).toUpperCase()).append("\n");
            out.append(indent()).append("  return ").append(constantName(originalFieldName).toUpperCase()).append(";\n");
        }
        out.append(indent()).append("default:\n");
        out.append(indent()).append("  return null;\n");
        indentLevel--;
        out.append(indent()).append("}\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");

        out.append(indent()).append("/**\n");
        out.append(indent()).append(" * Find the _Fields constant that matches fieldId, throwing an exception\n");
        out.append(indent()).append(" * if it is not found.\n");
        out.append(indent()).append(" */\n");
        out.append(indent()).append("public static _Fields findByThriftIdOrThrow(int fieldId) {\n");
        indentLevel++;
        out.append(indent()).append("_Fields fields = findByThriftId(fieldId);\n");
        out.append(indent()).append("if (fields == null) throw new java.lang.IllegalArgumentException(\"Field \" + ")
                .append("fieldId + \" doesn't exist!\");\n");
        out.append(indent()).append("return fields;\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");

        out.append(indent()).append("/**\n");
        out.append(indent()).append(" * Find the _Fields constant that matches name, or null if its not found.\n");
        out.append(indent()).append(" */\n");
        out.append(indent()).append(javaNullableAnnotation()).append("\n");
        out.append(indent()).append("public static _Fields findByName(java.lang.String name) {\n");
        indentLevel++;
        out.append(indent()).append("return byName.get(name);\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");

        out.append(indent()).append("private final short _thriftId;\n");
        out.append(indent()).append("private final java.lang.String _fieldName;\n\n");

        out.append(indent()).append("_Fields(short thriftId, java.lang.String fieldName) {\n");
        indentLevel++;
        out.append(indent()).append("_thriftId = thriftId;\n");
        out.append(indent()).append("_fieldName = fieldName;\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");

        out.append(indent()).append(javaOverrideAnnotation()).append("\n");
        out.append(indent()).append("public short getThriftFieldId() {\n");
        indentLevel++;
        out.append(indent()).append("return _thriftId;\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");

        out.append(indent()).append(javaOverrideAnnotation()).append("\n");
        out.append(indent()).append("public java.lang.String getFieldName() {\n");
        indentLevel++;
        out.append(indent()).append("return _fieldName;\n");
        indentLevel--;
        out.append(indent()).append("}\n");
        indentLevel--;
        out.append(indent()).append("}\n");
    }

    private void generateIssetDefinitions(StructLikeNode struct) {
        List<FieldNode> fields = struct.getFields();
        if (!fields.isEmpty()) {
            out.append(indent()).append("// isset id assignments\n");

            int fieldsRequiringIssetHandlingCount = getIssetHandledFieldCount();

            // Define ISSET_ID constants first, only for fields that need them, using a running index.
            int currentIssetIndex = 0;
            // boolean issetIdsWerePrinted = false; // Not strictly needed with current logic
            for (FieldNode field : fields) {
                if (fieldNeedsIssetHandling(field)) {
                    String originalFieldName = field.getName();
                    String issetIdConstant = "__" + constantName(originalFieldName).toUpperCase() + "_ISSET_ID";
                    out.append(indent()).append("private static final int ").append(issetIdConstant)
                            .append(" = ").append(currentIssetIndex++).append(";\n");
                    // issetIdsWerePrinted = true;
                }
            }

            // Determine overall storage strategy based on the count of fields that need it
            IssetType issetStorageType = determineIssetStorageType(fieldsRequiringIssetHandlingCount);
            if (fieldsRequiringIssetHandlingCount > 0) {
                // If ISSET_IDs were printed, current line ends with \n, so indent() is needed for bitfield/vector.
                // If no ISSET_IDs were printed (this implies fieldsRequiringIssetHandlingCount is also 0 based on current logic),
                // this block won't be entered if fieldsRequiringIssetHandlingCount is 0.
                // If fieldsRequiringIssetHandlingCount > 0 and no ISSET_IDs printed (should not happen),
                // then out.append(indent()) is also correct.
                out.append(indent());
                if (issetStorageType == IssetType.PRIMITIVE) {
                    String primitiveBitfieldType = determinePrimitiveTypeForIsset(fieldsRequiringIssetHandlingCount);
                    out.append("private ").append(primitiveBitfieldType)
                            .append(" __isset_bitfield = 0;\n");
                } else if (issetStorageType == IssetType.BITSET) {
                    out.append("private java.util.BitSet __isset_bit_vector = new java.util.BitSet(")
                            .append(fieldsRequiringIssetHandlingCount).append(");\n");
                }
            } else if (currentIssetIndex > 0) { // Changed from issetIdsWerePrinted to currentIssetIndex
                 // This case: ISSET_IDs were printed (so currentIssetIndex > 0), but fieldsRequiringIssetHandlingCount is 0.
                 // This state implies an issue, as fieldNeedsIssetHandling drove both.
                 // However, if it were, the last ISSET_ID already printed a newline.
            }
            // Original logic for 'optionals' array (used by TupleScheme) seems okay.
            // It counts fields marked FieldNode.Requirement.OPTIONAL, which is distinct
            // from whether a field needs an __isset bit (e.g. required primitives in non-bean also need it).
            int optionalsCount = 0;
            for (FieldNode field : fields) {
                 if (field.getRequirement() == FieldNode.Requirement.OPTIONAL) {
                    optionalsCount++;
                }
            }

            if (optionalsCount > 0) {
                // If __isset_bitfield or __isset_bit_vector was printed, it ended with a \n.
                // If ISSET_ID constants were printed, they each ended with \n.
                // So, we need to ensure an indent if the line is not already started by a previous append.
                // The simplest is to always call indent() before this block if it's going to print.
                out.append(indent());
                StringBuilder output = new StringBuilder("private static final _Fields optionals[] = {");
                boolean firstOptional = true;
                for (FieldNode field : fields) {
                    String originalFieldName = field.getName(); // Use original name
                    if (field.getRequirement() == FieldNode.Requirement.OPTIONAL) {
                        if (!firstOptional) output.append(", ");
                        output.append("_Fields.").append(constantName(originalFieldName).toUpperCase());
                        firstOptional = false;
                    }
                }
                output.append("};");
                out.append(output.toString()).append("\n");
            }
        }
    }

    private void generateJavaMetaDataMap(StructLikeNode struct) {
        out.append(indent()).append("public static final java.util.Map<_Fields, ")
                .append("org.apache.thrift.meta_data.FieldMetaData> metaDataMap;\n");
        out.append(indent()).append("static {\n");
        indentLevel++;

        out.append(indent())
                .append("java.util.Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new ")
                .append("java.util.EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);\n");

        for (FieldNode field : struct.getFields()) {
            String originalFieldName = field.getName();
            TypeNode fieldType = field.getType();

            out.append(indent()).append("tmpMap.put(_Fields.").append(constantName(originalFieldName).toUpperCase())
                    .append(", new org.apache.thrift.meta_data.FieldMetaData(\"").append(originalFieldName).append("\", ");

            FieldNode.Requirement req = field.getRequirement();
            if (req == FieldNode.Requirement.REQUIRED) {
                out.append("org.apache.thrift.TFieldRequirementType.REQUIRED, ");
            } else if (req == FieldNode.Requirement.OPTIONAL) {
                out.append("org.apache.thrift.TFieldRequirementType.OPTIONAL, ");
            } else {
                out.append("org.apache.thrift.TFieldRequirementType.DEFAULT, ");
            }
            out.append("\n").append(indent()).append("    ");
            out.append(generateFieldValueMetaData(fieldType)).append("));\n");
        }

        out.append(indent()).append("metaDataMap = java.util.Collections.unmodifiableMap(tmpMap);\n");
        out.append(indent()).append("org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(")
                .append(getEffectiveJavaIdentifier(struct.getName())).append(".class, metaDataMap);\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");
    }

    private String generateFieldValueMetaData(TypeNode type) {
        TypeNode trueType = getTrueType(type);
        StringBuilder sb = new StringBuilder();

        if (trueType.isStruct() || trueType.isException()) {
            sb.append("new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, ")
                    .append(getTypeName(trueType, false, false, true, true)).append(")");
        } else if (trueType.isContainer()) {
            if (trueType.isList()) {
                TypeNode elemType = trueType.getChildNodes().get(0);
                sb.append("new org.apache.thrift.meta_data.ListMetaData(org.apache.thrift.protocol.TType.LIST, ")
                        .append(generateFieldValueMetaData(elemType)).append(")");
            } else if (trueType.isSet()) {
                TypeNode elemType = trueType.getChildNodes().get(0);
                sb.append("new org.apache.thrift.meta_data.SetMetaData(org.apache.thrift.protocol.TType.SET, ")
                        .append(generateFieldValueMetaData(elemType)).append(")");
            } else { // Map
                TypeNode keyType = trueType.getChildNodes().get(0);
                TypeNode valType = trueType.getChildNodes().get(1);
                String keyMeta = generateFieldValueMetaData(keyType);
                String valMeta = generateFieldValueMetaData(valType);
                sb.append("new org.apache.thrift.meta_data.MapMetaData(org.apache.thrift.protocol.TType.MAP, \n")
                  .append("            ").append(keyMeta).append(", \n")
                  .append("            ").append(valMeta).append(")");
            }
        } else if (trueType.isEnum()) {
            sb.append("new org.apache.thrift.meta_data.EnumMetaData(org.apache.thrift.protocol.TType.ENUM, ")
                    .append(getTypeName(trueType, false, false, true, true)).append(")");
        } else {
            sb.append("new org.apache.thrift.meta_data.FieldValueMetaData(").append(typeToEnum(trueType));
            if (trueType.isBinary()) {
                sb.append(", true");
            }
            if (type.isTypedef() && !type.getName().equals(trueType.getName())) {
                sb.append(", \"").append(type.getName()).append("\"");
            }
            sb.append(")");
        }
        return sb.toString();
    }

    private void generateConstructors(StructLikeNode struct) {
        generateDefaultConstructor(struct);
        generateFullConstructor(struct);
        generateCopyConstructor(struct);
        generateDeepCopyMethod(struct);
    }

    private void generateClearMethod(StructLikeNode struct) {
        out.append(indent()).append(javaOverrideAnnotation()).append("\n");
        out.append(indent()).append("public void clear() {\n");
        indentLevel++;
        for (FieldNode field : struct.getFields()) {
            String originalFieldName = field.getName();
            String capName = capitalizedName(originalFieldName);
            TypeNode fieldType = field.getType();
            TypeNode trueType = getTrueType(fieldType); // Use trueType for checks

            // TODO: Add logic to reset to IDL default if field.getConstValue() is not null, like in C++

            if (typeCanBeNull(trueType)) { // Check trueType
                out.append(indent()).append("this.").append(originalFieldName).append(" = null;\n");
            } else { // Primitive types
                // If it's a primitive, its isSet flag should be cleared.
                out.append(indent()).append("set").append(capName).append("IsSet(false);\n");

                // Reset to Java default for primitives
                if (trueType instanceof BaseTypeNode) { // Check trueType
                    BaseTypeNode.BaseTypeEnum baseTypeEnum = ((BaseTypeNode) trueType).getType();
                    switch (baseTypeEnum) {
                        case BOOL:
                            out.append(indent()).append("this.").append(originalFieldName).append(" = false;\n");
                            break;
                        case BYTE: // Covers i8 as well due to BaseTypeNode mapping
                        case I16:
                        case I32:
                        case I64:
                            out.append(indent()).append("this.").append(originalFieldName).append(" = 0;\n");
                            break;
                        case DOUBLE:
                            out.append(indent()).append("this.").append(originalFieldName).append(" = 0.0;\n");
                            break;
                        // STRING, BINARY, UUID are handled by typeCanBeNull(trueType) path
                    }
                }
            }
        }
        indentLevel--;
        out.append(indent()).append("}\n\n");
    }

    private void generateDefaultConstructor(StructLikeNode struct) {
        out.append(indent()).append("public ").append(getEffectiveJavaIdentifier(struct.getName())).append("() {\n");
        // Default values are handled by field initializers or Java defaults.
        // Isset members are initialized at their declaration.
        out.append(indent()).append("}\n\n");
    }

    private void generateFullConstructor(StructLikeNode struct) {
        List<FieldNode> fullConstructorFields = new ArrayList<>();
        boolean allOptional = true;
        for (FieldNode field : struct.getFields()) {
            if (field.getRequirement() != FieldNode.Requirement.OPTIONAL) {
                fullConstructorFields.add(field);
                allOptional = false;
            }
        }

        if (!struct.getFields().isEmpty() && !allOptional) {
            out.append(indent()).append("public ").append(getEffectiveJavaIdentifier(struct.getName())).append("(\n");
            indentLevel++;
            for (int i = 0; i < fullConstructorFields.size(); i++) {
                FieldNode field = fullConstructorFields.get(i);
                TypeNode fieldType = field.getType();
                out.append(indent()).append(getTypeName(fieldType))
                        .append(" ").append(field.getName());
                if (i < fullConstructorFields.size() - 1) {
                    out.append(",\n");
                }
            }
            out.append(")\n");
            indentLevel--;
            out.append(indent()).append("{\n");
            indentLevel++;

            out.append(indent()).append("this();\n");
            for (FieldNode field : fullConstructorFields) {
                String originalFieldName = field.getName();
                TypeNode fieldType = field.getType();

                if (fieldType.isBinary() && !unsafeBinaries) {
                    out.append(indent()).append("this.").append(originalFieldName)
                            .append(" = org.apache.thrift.TBaseHelper.copyBinary(").append(originalFieldName).append(");\n");
                } else {
                    out.append(indent()).append("this.").append(originalFieldName).append(" = ").append(originalFieldName).append(";\n");
                }
                // For fields in the full constructor, if they are primitive (not nullable), their isset flag must be set.
                if (!typeCanBeNull(getTrueType(fieldType))) {
                    out.append(indent()).append("set").append(capitalizedName(originalFieldName)).append("IsSet(true);\n");
                }
            }
            indentLevel--;
            out.append(indent()).append("}\n\n");
        }
    }

    private void generateCopyConstructor(StructLikeNode struct) {
        String structJavaName = getEffectiveJavaIdentifier(struct.getName());
        out.append(indent()).append("/**\n");
        out.append(indent()).append(" * Performs a deep copy on <i>other</i>.\n");
        out.append(indent()).append(" */\n");
        out.append(indent()).append("public ").append(structJavaName).append("(").append(structJavaName).append(" other) {\n");
        indentLevel++;

        int fieldCountForIsset = getIssetHandledFieldCount();
        IssetType issetStorageType = determineIssetStorageType(fieldCountForIsset);

        if (fieldCountForIsset > 0) {
            if (issetStorageType == IssetType.PRIMITIVE) {
                out.append(indent()).append("__isset_bitfield = other.__isset_bitfield;\n");
            } else if (issetStorageType == IssetType.BITSET) {
                out.append(indent()).append("__isset_bit_vector = new java.util.BitSet(other.__isset_bit_vector.length());\n");
                out.append(indent()).append("__isset_bit_vector.or(other.__isset_bit_vector);\n");
            }
        }

        for (FieldNode field : struct.getFields()) {
            String originalFieldName = field.getName();
            TypeNode fieldType = field.getType();
            String capName = capitalizedName(originalFieldName);

            // Aligning with C++: always check other.isSet<FieldName>() in copy constructor
            out.append(indent()).append("if (other.isSet").append(capName).append("()) {\n");
            indentLevel++;

            String thisFieldName = "this." + originalFieldName;
            String otherFieldName = "other." + originalFieldName;

            if (fieldType.isContainer()) {
                generateDeepCopyContainer(fieldType, otherFieldName, "__this__"+originalFieldName);
                out.append(indent()).append(thisFieldName).append(" = __this__").append(originalFieldName).append(";\n");
            } else {
                out.append(indent()).append(thisFieldName).append(" = ")
                   .append(generateDeepCopyNonContainer(fieldType, otherFieldName))
                   .append(";\n");
            }
            // Closing the "if (other.isSet<CapName>())" block
            indentLevel--;
            out.append(indent()).append("}\n");
        }
        indentLevel--;
        out.append(indent()).append("}\n\n");
    }

    private void generateDeepCopyMethod(StructLikeNode struct) {
        String structName = getEffectiveJavaIdentifier(struct.getName());
        out.append(indent()).append(javaOverrideAnnotation()).append("\n");
        out.append(indent()).append("public ").append(structName).append(" deepCopy() {\n");
        indentLevel++;
        out.append(indent()).append("return new ").append(structName).append("(this);\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");
    }

    private void generateDeepCopyContainer(TypeNode type, String sourceName, String destName) {
        TypeNode trueType = getTrueType(type);

        // Check if we can use copy constructor for efficiency (for base types)
        boolean copyConstructContainer = false;
        if (trueType.isMap()) {
            TypeNode keyType = getTrueType(trueType.getChildNodes().get(0));
            TypeNode valueType = getTrueType(trueType.getChildNodes().get(1));
            copyConstructContainer = keyType.isBaseType() && valueType.isBaseType();
        } else {
            TypeNode elemType = trueType.isList()
                    ? getTrueType(trueType.getChildNodes().get(0))
                    : getTrueType(trueType.getChildNodes().get(0));
            copyConstructContainer = elemType.isBaseType();
        }

        if (copyConstructContainer) {
            // Deep copy of base types can be done more efficiently with copy constructor
            out.append(indent()).append(getTypeName(trueType, true, false)).append(" ")
                    .append(destName).append(" = new ")
                    .append(getTypeName(trueType, false, true)).append("(")
                    .append(sourceName).append(");\n");
            return;
        }

        // For non-base type elements, we need to construct and copy each element
        String constructorArgs = "";
        if ((trueType.isSet() && getTrueType(trueType.getChildNodes().get(0)).isEnum()) ||
                (trueType.isMap() && getTrueType(trueType.getChildNodes().get(0)).isEnum())) {
            // For enum collections, we need the enum class
            constructorArgs = getTypeName(getTrueType(trueType.getChildNodes().get(0)), false, false, true, true);
        } else if (!(sortedContainers && (trueType.isMap() || trueType.isSet()))) {
            // Unsorted containers accept a capacity value
            constructorArgs = sourceName + ".size()";
        }

        // Initialize the container
        if (trueType.isSet() && getTrueType(trueType.getChildNodes().get(0)).isEnum() && !sortedContainers) {
            out.append(indent()).append(getTypeName(trueType, true, false)).append(" ")
                    .append(destName).append(" = ")
                    .append("java.util.EnumSet.noneOf(").append(constructorArgs).append(");\n");
        } else {
            out.append(indent()).append(getTypeName(trueType, true, false)).append(" ")
                    .append(destName).append(" = new ")
                    .append(getTypeName(trueType, false, true)).append("(")
                    .append(constructorArgs).append(");\n");
        }

        // Element names for iteration
        String iteratorElementName = getNextTempVarName("_element");
        String resultElementName = destName + "_copy";

        if (trueType.isMap()) {
            TypeNode keyType = getTrueType(trueType.getChildNodes().get(0));
            TypeNode valueType = getTrueType(trueType.getChildNodes().get(1));

            out.append(indent()).append("for (java.util.Map.Entry<")
                    .append(getTypeName(keyType, true, false)).append(", ")
                    .append(getTypeName(valueType, true, false)).append("> ")
                    .append(iteratorElementName).append(" : ")
                    .append(sourceName).append(".entrySet()) {\n");
            indentLevel++;

            out.append(indent()).append(getTypeName(keyType, true, false)).append(" ")
                    .append(iteratorElementName).append("_key = ")
                    .append(iteratorElementName).append(".getKey();\n");

            out.append(indent()).append(getTypeName(valueType, true, false)).append(" ")
                    .append(iteratorElementName).append("_value = ")
                    .append(iteratorElementName).append(".getValue();\n");

            // Handle key copy
            if (keyType.isContainer()) {
                generateDeepCopyContainer(keyType, iteratorElementName + "_key", resultElementName + "_key");
            } else {
                out.append(indent()).append(getTypeName(keyType, true, false)).append(" ")
                        .append(resultElementName).append("_key = ")
                        .append(generateDeepCopyNonContainer(keyType, iteratorElementName + "_key"))
                        .append(";\n");
            }

            // Handle value copy
            if (valueType.isContainer()) {
                generateDeepCopyContainer(valueType, iteratorElementName + "_value", resultElementName + "_value");
            } else {
                out.append(indent()).append(getTypeName(valueType, true, false)).append(" ")
                        .append(resultElementName).append("_value = ")
                        .append(generateDeepCopyNonContainer(valueType, iteratorElementName + "_value"))
                        .append(";\n");
            }

            out.append(indent()).append(destName).append(".put(")
                    .append(resultElementName).append("_key, ")
                    .append(resultElementName).append("_value);\n");

            indentLevel--;
            out.append(indent()).append("}\n");
        } else {
            // Set or List
            TypeNode elemType = trueType.isList()
                    ? getTrueType(trueType.getChildNodes().get(0))
                    : getTrueType(trueType.getChildNodes().get(0));

            out.append(indent()).append("for (").append(getTypeName(elemType, true, false))
                    .append(" ").append(iteratorElementName).append(" : ")
                    .append(sourceName).append(") {\n");

            indentLevel++;

            if (elemType.isContainer()) {
                // Recursive deep copy
                generateDeepCopyContainer(elemType, iteratorElementName, resultElementName);
                out.append(indent()).append(destName).append(".add(").append(resultElementName).append(");\n");
            } else {
                // Iterative copy
                if (elemType.isBinary()) {
                    out.append(indent()).append("java.nio.ByteBuffer temp_binary_element = ")
                            .append(generateDeepCopyNonContainer(elemType, iteratorElementName))
                            .append(";\n");
                    out.append(indent()).append(destName).append(".add(temp_binary_element);\n");
                } else {
                    out.append(indent()).append(destName).append(".add(")
                            .append(generateDeepCopyNonContainer(elemType, iteratorElementName))
                            .append(");\n");
                }
            }

            indentLevel--;
            out.append(indent()).append("}\n");
        }
    }

    private String generateDeepCopyNonContainer(TypeNode type, String sourceName) {
        TypeNode trueType = getTrueType(type);
        if (trueType.isBaseType() || trueType.isEnum()) {
            if (trueType.isBinary() && !unsafeBinaries) {
                return "org.apache.thrift.TBaseHelper.copyBinary(" + sourceName + ")";
            } else {
                return sourceName;
            }
        } else if (trueType.isStruct() || trueType.isException()) {
            return "new " + getTypeName(trueType, false, false, false, true) + "(" + sourceName + ")";
        } else if (trueType.isContainer()){
             System.err.println("Warning: generateDeepCopyNonContainer called with container type. Fallback to shallow copy for " + sourceName);
             return sourceName + "; /* TODO: generateDeepCopyContainer was expected for " + sourceName + " */ ";
        }
        return sourceName;
    }

    private String capitalizedName(String name) {
        if (name == null || name.isEmpty()) {
            return name;
        }
        return name.substring(0, 1).toUpperCase() + name.substring(1);
    }

    private void generateGettersAndSetters(StructLikeNode struct) {
        for (FieldNode field : struct.getFields()) {
            TypeNode fieldType = field.getType();
            String originalFieldName = field.getName();

            TypeNode trueType = getTrueType(fieldType);
            String capName = capitalizedName(originalFieldName);
            boolean isOptional = field.getRequirement() == FieldNode.Requirement.OPTIONAL;

            if (trueType.isContainer()) {
                generateContainerMethods(field, trueType, originalFieldName, capName, isOptional);
            }
            generateGetter(field, trueType, originalFieldName, capName, isOptional);
            generateSetter(field, trueType, originalFieldName, capName);
            generateUnsetter(field, trueType, originalFieldName, capName);
            generateIsSetMethod(field, trueType, originalFieldName, capName);
            generateSetIsSetMethod(field, trueType, originalFieldName, capName);
        }
    }

    private void generateContainerMethods(FieldNode field, TypeNode trueType, String fieldName, String capName, boolean isOptional) {
        if (useOptionType && isOptional) {
            String optionClassName = useJdk8OptionType ? "java.util.Optional" : "org.apache.thrift.Option";
            out.append(indent()).append("public ").append(optionClassName).append("<Integer> get").append(capName).append("Size() {\n");
            indentLevel++;
            out.append(indent()).append("if (this.").append(fieldName).append(" == null) {\n");
            indentLevel++;
            out.append(indent()).append("return ").append(optionClassName).append(".empty();\n");
            indentLevel--;
            out.append(indent()).append("} else {\n");
            indentLevel++;
            out.append(indent()).append("return ").append(optionClassName).append(".of(this.").append(fieldName).append(".size());\n");
            indentLevel--;
            out.append(indent()).append("}\n");
            indentLevel--;
            out.append(indent()).append("}\n\n");
        } else {
            out.append(indent()).append("public int get").append(capName).append("Size() {\n");
            indentLevel++;
            out.append(indent()).append("return (this.").append(fieldName).append(" == null) ? 0 : this.").append(fieldName).append(".size();\n");
            indentLevel--;
            out.append(indent()).append("}\n\n");
        }

        if (trueType.isList() || trueType.isSet()) {
            TypeNode elemType = getTrueType(trueType.getChildNodes().get(0));
            String elemTypeName = getTypeName(elemType, true, false, false, true);
            if (useOptionType && isOptional) {
                String optionClassName = useJdk8OptionType ? "java.util.Optional" : "org.apache.thrift.Option";
                out.append(indent()).append("public ").append(optionClassName).append("<java.util.Iterator<").append(elemTypeName).append(">> get")
                        .append(capName).append("Iterator() {\n");
                indentLevel++;
                out.append(indent()).append("if (this.").append(fieldName).append(" == null) {\n");
                indentLevel++;
                out.append(indent()).append("return ").append(optionClassName).append(".empty();\n");
                indentLevel--;
                out.append(indent()).append("} else {\n");
                indentLevel++;
                out.append(indent()).append("return ").append(optionClassName).append(".of(this.").append(fieldName).append(".iterator());\n");
                indentLevel--;
                out.append(indent()).append("}\n");
                indentLevel--;
                out.append(indent()).append("}\n\n");
            } else {
                out.append(indent()).append(javaNullableAnnotation()).append("\n");
                out.append(indent()).append("public java.util.Iterator<").append(elemTypeName).append("> get").append(capName).append("Iterator() {\n");
                indentLevel++;
                out.append(indent()).append("return (this.").append(fieldName).append(" == null) ? null : this.").append(fieldName).append(".iterator();\n");
                indentLevel--;
                out.append(indent()).append("}\n\n");
            }

            out.append(indent()).append("public void addTo").append(capName).append("(").append(getTypeName(elemType)).append(" elem) {\n");
            indentLevel++;
            out.append(indent()).append("if (this.").append(fieldName).append(" == null) {\n");
            indentLevel++;
            String containerInitType = getTypeName(trueType, false, true, false, false);
            if (elemType.isEnum() && !sortedContainers && trueType.isSet()) {
                out.append(indent()).append("this.").append(fieldName).append(" = java.util.EnumSet.noneOf(")
                        .append(getTypeName(elemType, true, false, true, true)).append(");\n");
            } else {
                out.append(indent()).append("this.").append(fieldName).append(" = new ").append(containerInitType).append("();\n");
            }
            indentLevel--;
            out.append(indent()).append("}\n");
            out.append(indent()).append("this.").append(fieldName).append(".add(elem);\n");
            indentLevel--;
            out.append(indent()).append("}\n\n");

        } else if (trueType.isMap()) {
            TypeNode keyType = getTrueType(trueType.getChildNodes().get(0));
            TypeNode valueType = getTrueType(trueType.getChildNodes().get(1));
            out.append(indent()).append("public void putTo").append(capName).append("(")
                    .append(getTypeName(keyType)).append(" key, ")
                    .append(getTypeName(valueType)).append(" val) {\n");
            indentLevel++;
            out.append(indent()).append("if (this.").append(fieldName).append(" == null) {\n");
            indentLevel++;
            String mapInitType = getTypeName(trueType, false, true, false, false);
            if (keyType.isEnum() && !sortedContainers) {
                out.append(indent()).append("this.").append(fieldName).append(" = new ").append(mapInitType).append("(")
                        .append(getTypeName(keyType, true, false, true, true)).append(");\n");
            } else {
                out.append(indent()).append("this.").append(fieldName).append(" = new ").append(mapInitType).append("();\n");
            }
            indentLevel--;
            out.append(indent()).append("}\n");
            out.append(indent()).append("this.").append(fieldName).append(".put(key, val);\n");
            indentLevel--;
            out.append(indent()).append("}\n\n");
        }
    }

    private void generateGetter(FieldNode field, TypeNode trueType, String fieldName, String capName, boolean isOptional) {
        generateJavaDoc(field);
        if (trueType.isBinary()) {
            out.append(indent()).append("public byte[] get").append(capName).append("() {\n");
            indentLevel++;
            out.append(indent()).append("java.nio.ByteBuffer bf = bufferFor").append(capName).append("();\n");
            out.append(indent()).append("return (bf == null ? null : bf.array());\n");
            indentLevel--;
            out.append(indent()).append("}\n\n");

            out.append(indent()).append(javaNullableAnnotation()).append("\n");
            out.append(indent()).append("public java.nio.ByteBuffer bufferFor").append(capName).append("() {\n");
            indentLevel++;
            if (unsafeBinaries) {
                out.append(indent()).append("return this.").append(fieldName).append(";\n");
            } else {
                out.append(indent()).append("return org.apache.thrift.TBaseHelper.copyBinary(this.").append(fieldName).append(");\n");
            }
            indentLevel--;
            out.append(indent()).append("}\n\n");
        } else {
            String getterName;
            if (trueType.isBaseType() && "bool".equals(trueType.getName())) {
                getterName = "is" + capName;
            } else {
                getterName = "get" + capName;
            }

            if (useOptionType && isOptional) {
                String optionClassName = useJdk8OptionType ? "java.util.Optional" : "org.apache.thrift.Option";
                out.append(indent()).append("public ").append(optionClassName).append("<").append(getTypeName(trueType, true, false, false, false)).append("> ")
                        .append(getterName).append("() {\n");
                indentLevel++;
                out.append(indent()).append("if (this.isSet").append(capName).append("()) {\n");
                indentLevel++;
                out.append(indent()).append("return ").append(optionClassName).append(".of(this.").append(fieldName).append(");\n");
                indentLevel--;
                out.append(indent()).append("} else {\n");
                indentLevel++;
                out.append(indent()).append("return ").append(optionClassName).append(".empty();\n");
                indentLevel--;
                out.append(indent()).append("}\n");
                indentLevel--;
                out.append(indent()).append("}\n\n");
            } else {
                if (typeCanBeNull(trueType)) {
                    out.append(indent()).append(javaNullableAnnotation()).append("\n");
                }
                out.append(indent()).append("public ").append(getTypeName(trueType)).append(" ")
                        .append(getterName).append("() {\n");
                indentLevel++;
                out.append(indent()).append("return this.").append(fieldName).append(";\n");
                indentLevel--;
                out.append(indent()).append("}\n\n");
            }
        }
    }

    private void generateSetter(FieldNode field, TypeNode trueType, String fieldName, String capName) {
        generateJavaDoc(field);
        String returnType = beanStyle ? "void" : getEffectiveJavaIdentifier(structLikeNode.getName());
        String params;

        if (trueType.isBinary()) {
            params = (typeCanBeNull(trueType) ? javaNullableAnnotation() + " " : "") +
                    "java.nio.ByteBuffer" + " " + fieldName;

            out.append(indent()).append("public ").append(returnType).append(" set").append(capName).append("(").append(params).append(") {\n");
            indentLevel++;
            if (unsafeBinaries) {
                out.append(indent()).append("this.").append(fieldName).append(" = ").append(fieldName).append(";\n");
            } else {
                out.append(indent()).append("this.").append(fieldName).append(" = org.apache.thrift.TBaseHelper.copyBinary(").append(fieldName).append(");\n");
            }
            if (!beanStyle) {
                out.append(indent()).append("return this;\n");
            }
            indentLevel--;
            out.append(indent()).append("}\n\n");

            generateJavaDoc(field);
            params = (typeCanBeNull(trueType) ? javaNullableAnnotation() + " " : "") +
                    "byte[]" + " " + fieldName;

            out.append(indent()).append("public ").append(returnType).append(" set").append(capName).append("(").append(params).append(") {\n");
            indentLevel++;
            out.append(indent()).append("set").append(capName).append("(").append(fieldName)
                    .append(" == null ? (java.nio.ByteBuffer)null");
            if (unsafeBinaries) {
                out.append(" : java.nio.ByteBuffer.wrap(").append(fieldName).append("));\n");
            } else {
                out.append(" : java.nio.ByteBuffer.wrap(").append(fieldName).append(".clone()));\n");
            }
            if (!beanStyle) {
                out.append(indent()).append("return this;\n");
            }
            indentLevel--;
            out.append(indent()).append("}\n\n");

        } else {
            params = (typeCanBeNull(trueType) ? javaNullableAnnotation() + " " : "") +
                    getTypeName(trueType) + " " + fieldName;
            out.append(indent()).append("public ").append(returnType).append(" set").append(capName).append("(").append(params).append(") {\n");
            indentLevel++;
            out.append(indent()).append("this.").append(fieldName).append(" = ").append(fieldName).append(";\n");
            if (fieldNeedsIssetHandling(field) && !typeCanBeNull(trueType)) {
                out.append(indent()).append("set").append(capName).append("IsSet(true);\n");
            }
            if (!beanStyle) {
                out.append(indent()).append("return this;\n");
            }
            indentLevel--;
            out.append(indent()).append("}\n\n");
        }
    }

    private void generateUnsetter(FieldNode field, TypeNode trueType, String fieldName, String capName) {
        out.append(indent()).append("public void unset").append(capName).append("() {\n");
        indentLevel++;
        if (typeCanBeNull(trueType)) {
            out.append(indent()).append("this.").append(fieldName).append(" = null;\n");
        } else {
            if (fieldNeedsIssetHandling(field)) {
                IssetType issetStorageType = determineIssetStorageType(getIssetHandledFieldCount());
                String issetIdentifier = issetStorageType == IssetType.BITSET ? "__isset_bit_vector" : "__isset_bitfield";
                String clearBitMethodCall;
                String issetIndexConstant = issetFieldId(field);

                if (issetStorageType == IssetType.BITSET) {
                    clearBitMethodCall = issetIdentifier + ".clear(" + issetIndexConstant + ");\n";
                } else if (issetStorageType == IssetType.PRIMITIVE) {
                    clearBitMethodCall = issetIdentifier + " = org.apache.thrift.EncodingUtils.clearBit(" + issetIdentifier + ", " + issetIndexConstant + ");\n";
                } else {
                    clearBitMethodCall = "// Isset type NONE for field " + field.getName() + ", though it needs handling. Error in logic?\n";
                }
                out.append(indent()).append(clearBitMethodCall);
            }
        }
        indentLevel--;
        out.append(indent()).append("}\n\n");
    }

    private void generateIsSetMethod(FieldNode field, TypeNode trueType, String fieldName, String capName) {
        out.append(indent()).append("/** Returns true if field ").append(fieldName).append(" is set (has been assigned a value) and false otherwise */\n");
        out.append(indent()).append("public boolean isSet").append(capName).append("() {\n");
        indentLevel++;
        if (fieldNeedsIssetHandling(field)) {
            IssetType issetStorageType = determineIssetStorageType(getIssetHandledFieldCount());
            if (issetStorageType == IssetType.NONE) {
                 out.append(indent()).append("return false; // Should not happen if fieldNeedsIssetHandling is true\n");
            } else {
                String issetIdentifier = issetStorageType == IssetType.BITSET ? "__isset_bit_vector" : "__isset_bitfield";
                String testBitMethodCall;
                String issetIndexConstant = issetFieldId(field);

                if (issetStorageType == IssetType.BITSET) {
                    testBitMethodCall = "return " + issetIdentifier + ".get(" + issetIndexConstant + ");\n";
                } else { // PRIMITIVE
                    testBitMethodCall = "return org.apache.thrift.EncodingUtils.testBit(" + issetIdentifier + ", " + issetIndexConstant + ");\n";
                }
                out.append(indent()).append(testBitMethodCall);
            }
        } else {
            if (typeCanBeNull(trueType)) {
                out.append(indent()).append("return this.").append(fieldName).append(" != null;\n");
            } else {
                out.append(indent()).append("return true; // Not using explicit isset bit, value is always considered present or null checked\n");
            }
        }
        indentLevel--;
        out.append(indent()).append("}\n\n");
    }

    private void generateSetIsSetMethod(FieldNode field, TypeNode trueType, String fieldName, String capName) {
        out.append(indent()).append("public void set").append(capName).append("IsSet(boolean value) {\n");
        indentLevel++;
        if (fieldNeedsIssetHandling(field)) {
            IssetType issetStorageType = determineIssetStorageType(getIssetHandledFieldCount());
             if (issetStorageType != IssetType.NONE) {
                String issetIdentifier = issetStorageType == IssetType.BITSET ? "__isset_bit_vector" : "__isset_bitfield";
                String setBitMethodCall;
                String issetIndexConstant = issetFieldId(field);

                if (issetStorageType == IssetType.BITSET) {
                    setBitMethodCall = issetIdentifier + ".set(" + issetIndexConstant + ", value);\n";
                } else { // PRIMITIVE
                    setBitMethodCall = issetIdentifier + " = org.apache.thrift.EncodingUtils.setBit(" + issetIdentifier + ", " + issetIndexConstant + ", value);\n";
                }
                out.append(indent()).append(setBitMethodCall);
            }
        } else if (typeCanBeNull(trueType)) { // For nullable types not using explicit bit, unsetting means nulling
             out.append(indent()).append("if (!value) {\n");
            indentLevel++;
            out.append(indent()).append("this.").append(fieldName).append(" = null;\n");
            indentLevel--;
            out.append(indent()).append("}\n");
        }
        indentLevel--;
        out.append(indent()).append("}\n\n");
    }

    private void generateJavaStructEquality(StructLikeNode struct) {
        generateEqualsObjectMethod(struct);
        generateEqualsTypedMethod(struct);
        generateHashCodeMethod(struct);
    }

    private void generateEqualsObjectMethod(StructLikeNode struct) {
        String structName = getEffectiveJavaIdentifier(struct.getName());
        out.append(indent()).append(javaOverrideAnnotation()).append("\n");
        out.append(indent()).append("public boolean equals(java.lang.Object that) {\n");
        indentLevel++;
        out.append(indent()).append("if (that instanceof ").append(structName).append(")\n");
        indentLevel++;
        out.append(indent()).append("return this.equals((").append(structName).append(")that);\n");
        indentLevel--;
        out.append(indent()).append("return false;\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");
    }

    private void generateEqualsTypedMethod(StructLikeNode struct) {
        String structName = getEffectiveJavaIdentifier(struct.getName());
        out.append(indent()).append("public boolean equals(").append(structName).append(" that) {\n");
        indentLevel++;
        out.append(indent()).append("if (that == null)\n"); // No braces for single statement as per some test expectations
        out.append(indent()).append("  return false;\n");
        // indentLevel--; // No, this was wrong, single statement doesn't change level
        out.append(indent()).append("if (this == that)\n");
        out.append(indent()).append("  return true;\n");

        for (FieldNode field : struct.getFields()) {
            String originalFieldName = field.getName();
            TypeNode fieldType = field.getType();

            String capName = capitalizedName(originalFieldName);
            TypeNode trueType = getTrueType(fieldType);

            out.append("\n");
            // Simplified presence check: isSet<FieldName>() correctly handles all cases.
            out.append(indent()).append("boolean this_present_").append(originalFieldName).append(" = this.isSet").append(capName).append("();\n");
            out.append(indent()).append("boolean that_present_").append(originalFieldName).append(" = that.isSet").append(capName).append("();\n");

            out.append(indent()).append("if (this_present_").append(originalFieldName).append(" || that_present_").append(originalFieldName).append(") {\n");
            indentLevel++;
            out.append(indent()).append("if (!(this_present_").append(originalFieldName).append(" && that_present_").append(originalFieldName).append("))\n");
            out.append(indent()).append("  return false;\n");
            // indentLevel--; // No, this was wrong

            String thisFieldValue = "this." + originalFieldName;
            String thatFieldValue = "that." + originalFieldName;
            String comparison;

            // Simplified comparison logic
            if (trueType.isBinary()) {
                comparison = "!" + thisFieldValue + ".equals(" + thatFieldValue + ")";
            } else if (typeCanBeNull(trueType) || trueType.isStruct() || trueType.isContainer() || trueType.isEnum()) {
                comparison = "!" + thisFieldValue + ".equals(" + thatFieldValue + ")";
            } else {
                comparison = thisFieldValue + " != " + thatFieldValue;
            }
            out.append(indent()).append("if (").append(comparison).append(")\n");
            out.append(indent()).append("  return false;\n");
            // indentLevel++; // No
            // indentLevel--; // No
            indentLevel--;
            out.append(indent()).append("}\n");
        }
        out.append("\n");
        out.append(indent()).append("return true;\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");
    }

    private void generateHashCodeMethod(StructLikeNode struct) {
        final int PRIME_MULTIPLIER = 8191;
        final int HASH_PRIME_FOR_SET_TRUE = 131071;
        final int HASH_PRIME_FOR_SET_FALSE = 524287;

        out.append(indent()).append(javaOverrideAnnotation()).append("\n");
        out.append(indent()).append("public int hashCode() {\n");
        indentLevel++;
        out.append(indent()).append("int hashCode = 1;\n\n");

        boolean firstFieldInHash = true;
        for (FieldNode field : struct.getFields()) {
            if (!firstFieldInHash) {
                out.append("\n");
            }
            firstFieldInHash = false;

            String originalFieldName = field.getName();
            TypeNode fieldType = field.getType();
            String capName = capitalizedName(originalFieldName);
            TypeNode trueType = getTrueType(fieldType);

            if (field.getRequirement() == FieldNode.Requirement.REQUIRED && !typeCanBeNull(trueType)) {
                out.append(indent()).append("hashCode = hashCode * ").append(PRIME_MULTIPLIER).append(" + ");
                String fieldValue = originalFieldName; // Use direct field name for required primitives
                if (trueType.isBaseType()) {
                    String baseName = trueType.getName();
                    switch (baseName) {
                        case "bool":
                            out.append("(").append(fieldValue).append(" ? ").append(HASH_PRIME_FOR_SET_TRUE).append(" : ").append(HASH_PRIME_FOR_SET_FALSE).append(");\n");
                            break;
                        case "byte": case "i8":
                        case "short": case "i16":
                        case "int": case "i32":
                            out.append(fieldValue).append(";\n");
                            break;
                        case "long": case "i64":
                            out.append("org.apache.thrift.TBaseHelper.hashCode((long)").append(fieldValue).append(");\n");
                            break;
                        case "double":
                            out.append("org.apache.thrift.TBaseHelper.hashCode(").append(fieldValue).append(");\n"); // Removed cast
                            break;
                        default:
                            out.append("0); // Should not happen: unhandled required primitive base type in hashCode: ").append(baseName).append("\n");
                            break;
                    }
                } else {
                    out.append("0); // ERROR: Required non-nullable type is not base type? Type: ").append(trueType.getName()).append("\n");
                }
            } else {
                out.append(indent()).append("hashCode = hashCode * ").append(PRIME_MULTIPLIER)
                        .append(" + ((isSet").append(capName).append("()) ? ")
                        .append(HASH_PRIME_FOR_SET_TRUE).append(" : ").append(HASH_PRIME_FOR_SET_FALSE).append(");\n");
                out.append(indent()).append("if (isSet").append(capName).append("())\n");
                indentLevel++;
                out.append(indent()).append("hashCode = hashCode * ").append(PRIME_MULTIPLIER).append(" + ");

                String valueAccess = originalFieldName;

                if (trueType.isEnum()) {
                    out.append(valueAccess).append(".getValue();\n");
                } else if (trueType.isBaseType()) {
                    String baseName = trueType.getName();
                     if (trueType.isBinary()) baseName = "binary";
                    switch (baseName) {
                        case "string":
                        case "uuid":
                        case "binary":
                            out.append(valueAccess).append(".hashCode();\n");
                            break;
                        case "bool":
                             out.append("(").append(valueAccess).append(" ? ").append(HASH_PRIME_FOR_SET_TRUE).append(" : ").append(HASH_PRIME_FOR_SET_FALSE).append("));\n");
                             break;
                        case "byte": case "i8":
                        case "short": case "i16":
                        case "int": case "i32":
                             out.append(valueAccess).append(");\n");
                             break;
                        case "long": case "i64":
                             out.append("org.apache.thrift.TBaseHelper.hashCode((long)").append(valueAccess).append("));\n");
                             break;
                        case "double":
                             out.append("org.apache.thrift.TBaseHelper.hashCode(").append(valueAccess).append("));\n"); // Removed cast
                             break;
                        default:
                            out.append("0); // Unhandled optional base type in hashCode: ").append(baseName).append("\n");
                            break;
                    }
                } else {
                    out.append(valueAccess).append(".hashCode();\n");
                }
                indentLevel--;
            }
        }
        out.append("\n");
        out.append(indent()).append("return hashCode;\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");
    }

    private void generateJavaStructCompareTo(StructLikeNode struct) {
        String structName = getEffectiveJavaIdentifier(struct.getName());
        out.append(indent()).append(javaOverrideAnnotation()).append("\n");
        out.append(indent()).append("public int compareTo(").append(structName).append(" other) {\n");
        indentLevel++;

        out.append(indent()).append("if (!getClass().equals(other.getClass())) {\n");
        indentLevel++;
        out.append(indent()).append("return getClass().getName().compareTo(other.getClass().getName());\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");

        out.append(indent()).append("int lastComparison = 0;\n\n");

        for (FieldNode field : struct.getFields()) {
            String originalFieldName = field.getName();
            String capName = capitalizedName(originalFieldName);

            out.append(indent()).append("lastComparison = java.lang.Boolean.compare(isSet").append(capName).append("(), other.isSet").append(capName).append("());\n");
            out.append(indent()).append("if (lastComparison != 0) {\n");
            indentLevel++;
            out.append(indent()).append("return lastComparison;\n");
            indentLevel--;
            out.append(indent()).append("}\n");

            out.append(indent()).append("if (isSet").append(capName).append("()) {\n");
            indentLevel++;
            out.append(indent()).append("lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.").append(originalFieldName).append(", other.").append(originalFieldName).append(");\n");
            out.append(indent()).append("if (lastComparison != 0) {\n");
            indentLevel++;
            out.append(indent()).append("return lastComparison;\n");
            indentLevel--;
            out.append(indent()).append("}\n");
            indentLevel--;
            out.append(indent()).append("}\n");
        }

        out.append(indent()).append("return 0;\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");
    }

    private void generateJavaStructFieldById(StructLikeNode struct) {
        out.append(indent()).append(javaNullableAnnotation()).append("\n");
        out.append(indent()).append(javaOverrideAnnotation()).append("\n");
        out.append(indent()).append("public _Fields fieldForId(int fieldId) {\n");
        indentLevel++;
        out.append(indent()).append("return _Fields.findByThriftId(fieldId);\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");
    }

    private void generateSetFieldValueMethod(StructLikeNode struct) {
        out.append(indent()).append(javaOverrideAnnotation()).append("\n");
        out.append(indent()).append("public void setFieldValue(_Fields field, ")
                .append(javaNullableAnnotation()).append(" java.lang.Object value) {\n");
        indentLevel++;
        out.append(indent()).append("switch (field) {\n");

        List<FieldNode> fields = struct.getFields();
        for (int i = 0; i < fields.size(); i++) {
            FieldNode fieldNode = fields.get(i);
            String originalFieldName = fieldNode.getName();
            String capName = capitalizedName(originalFieldName);
            TypeNode fieldType = fieldNode.getType();
            TypeNode trueType = getTrueType(fieldType);

            out.append(indent()).append("case ").append(constantName(originalFieldName).toUpperCase()).append(":\n");
            indentLevel++;
            out.append(indent()).append("if (value == null) {\n");
            indentLevel++;
            out.append(indent()).append("unset").append(capName).append("();\n");
            indentLevel--;
            out.append(indent()).append("} else {\n");
            indentLevel++;
            String javaCastType = getTypeName(trueType, true, false, false, false);
            out.append(indent()).append("set").append(capName).append("((").append(javaCastType)
                    .append(")value);\n");
            indentLevel--;
            out.append(indent()).append("}\n");
            out.append(indent()).append("break;\n");
            indentLevel--;
            out.append("\n");
        }
        out.append(indent()).append("}\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");
    }

    private void generateGetFieldValueMethod(StructLikeNode struct) {
        out.append(indent()).append(javaNullableAnnotation()).append("\n");
        out.append(indent()).append(javaOverrideAnnotation()).append("\n");
        out.append(indent()).append("public java.lang.Object getFieldValue(_Fields field) {\n");
        indentLevel++;
        out.append(indent()).append("switch (field) {\n");

        List<FieldNode> fields = struct.getFields();
        for (int i = 0; i < fields.size(); i++) {
            FieldNode fieldNode = fields.get(i);
            String originalFieldName = fieldNode.getName();
            String capName = capitalizedName(originalFieldName);
            TypeNode fieldType = fieldNode.getType();
            TypeNode trueType = getTrueType(fieldType);

            out.append(indent()).append("case ").append(constantName(originalFieldName).toUpperCase()).append(":\n");
            indentLevel++;
            String getterName = (trueType.isBaseType() && "bool".equals(trueType.getName())) ?
                    "is" + capName : "get" + capName;
            out.append(indent()).append("return ").append(getterName).append("();\n");
            indentLevel--;
            out.append("\n");
        }
        out.append(indent()).append("}\n");
        out.append(indent()).append("throw new java.lang.IllegalStateException();\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");
    }

    private void generateIsSetFieldMethod(StructLikeNode struct) {
        out.append(indent()).append("/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */\n");
        out.append(indent()).append(javaOverrideAnnotation()).append("\n");
        out.append(indent()).append("public boolean isSet(_Fields field) {\n");
        indentLevel++;
        out.append(indent()).append("if (field == null) {\n");
        indentLevel++;
        out.append(indent()).append("throw new java.lang.IllegalArgumentException();\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");
        out.append(indent()).append("switch (field) {\n");

        List<FieldNode> fields = struct.getFields();
        for (int i = 0; i < fields.size(); i++) {
            FieldNode fieldNode = fields.get(i);
            String originalFieldName = fieldNode.getName();
            String capName = capitalizedName(originalFieldName);
            out.append(indent()).append("case ").append(constantName(originalFieldName).toUpperCase()).append(":\n");
            indentLevel++;
            out.append(indent()).append("return isSet").append(capName).append("();\n");
            indentLevel--;
        }
        out.append(indent()).append("}\n");
        out.append(indent()).append("throw new java.lang.IllegalStateException();\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");
    }

    private void generateJavaStructReader(StructLikeNode struct) {
        out.append(indent()).append(javaOverrideAnnotation()).append("\n");
        out.append(indent()).append("public void read(org.apache.thrift.protocol.TProtocol iprot) throws ")
                .append("org.apache.thrift.TException {\n");
        indentLevel++;
        out.append(indent()).append("scheme(iprot).read(iprot, this);\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");
    }

    private void generateJavaStructResultWriter(StructLikeNode struct) {
        out.append(indent()).append("public void write(org.apache.thrift.protocol.TProtocol oprot) throws ")
                .append("org.apache.thrift.TException {\n");
        indentLevel++;
        out.append(indent()).append("scheme(oprot).write(oprot, this);\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");
    }

    private void generateJavaStructWriter(StructLikeNode struct) {
        out.append(indent()).append(javaOverrideAnnotation()).append("\n");
        out.append(indent()).append("public void write(org.apache.thrift.protocol.TProtocol oprot) throws ")
                .append("org.apache.thrift.TException {\n");
        indentLevel++;
        out.append(indent()).append("scheme(oprot).write(oprot, this);\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");
    }

    private void generateJavaStructToString(StructLikeNode struct) {
        String structName = getEffectiveJavaIdentifier(struct.getName());
        out.append(indent()).append(javaOverrideAnnotation()).append("\n");
        out.append(indent()).append("public java.lang.String toString() {\n");
        indentLevel++;

        out.append(indent()).append("java.lang.StringBuilder sb = new java.lang.StringBuilder(\"").append(structName).append("(\");\n");
        out.append(indent()).append("boolean first = true;\n\n");

        boolean first = true;
        for (FieldNode field : struct.getFields()) {
            String originalFieldName = field.getName();
            String javaFieldName = makeValidJavaIdentifier(originalFieldName);
            String capName = capitalizedName(originalFieldName);
            TypeNode fieldType = field.getType();
            TypeNode trueType = getTrueType(fieldType);
            boolean isOptional = field.getRequirement() == FieldNode.Requirement.OPTIONAL;

            if (isOptional) {
                out.append(indent()).append("if (isSet").append(capName).append("()) {\n");
                indentLevel++;
            }

            if (!first) {
                out.append(indent()).append("if (!first) sb.append(\", \");\n");
            }
            out.append(indent()).append("sb.append(\"").append(originalFieldName).append(":\");\n");

            boolean canBeNull = typeCanBeNull(trueType);
            if (canBeNull) {
                out.append(indent()).append("if (this.").append(javaFieldName).append(" == null) {\n");
                indentLevel++;
                out.append(indent()).append("sb.append(\"null\");\n");
                indentLevel--;
                out.append(indent()).append("} else {\n");
                indentLevel++;
            }

            if (trueType.isBinary()) {
                out.append(indent()).append("org.apache.thrift.TBaseHelper.toString(this.").append(javaFieldName).append(", sb);\n");
            } else if (trueType.isSet() && getTrueType(trueType.getChildNodes().get(0)).isBinary()) {
                out.append(indent()).append("org.apache.thrift.TBaseHelper.toString(this.").append(javaFieldName).append(", sb);\n");
            } else if (trueType.isList() && getTrueType(trueType.getChildNodes().get(0)).isBinary()) {
                out.append(indent()).append("org.apache.thrift.TBaseHelper.toString(this.").append(javaFieldName).append(", sb);\n");
            } else {
                out.append(indent()).append("sb.append(this.").append(javaFieldName).append(");\n");
            }

            if (canBeNull) {
                indentLevel--;
                out.append(indent()).append("}\n");
            }

            out.append(indent()).append("first = false;\n");

            if (isOptional) {
                indentLevel--;
                out.append(indent()).append("}\n");
            }
            first = false;
        }

        out.append(indent()).append("sb.append(\")\");\n");
        out.append(indent()).append("return sb.toString();\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");
    }

    private void generateJavaStructToStringbak(StructLikeNode struct) {
        String structName = getEffectiveJavaIdentifier(struct.getName());
        out.append(indent()).append(javaOverrideAnnotation()).append("\n");
        out.append(indent()).append("public java.lang.String toString() {\n");
        indentLevel++;

        out.append(indent()).append("java.lang.StringBuilder sb = new java.lang.StringBuilder(\"").append(structName).append("(\");\n");
        out.append(indent()).append("boolean first = true;\n");

        for (FieldNode field : struct.getFields()) {
            String originalFieldName = field.getName();
            String capName = capitalizedName(originalFieldName);
            TypeNode trueType = getTrueType(field.getType());
            boolean isOptional = field.getRequirement() == FieldNode.Requirement.OPTIONAL;

            if (isOptional) {
                out.append(indent()).append("if (isSet").append(capName).append("()) {\n");
                indentLevel++;
            }

            out.append(indent()).append("if (!first) {\n");
            out.append(indent()).append("  sb.append(\", \");\n");
            out.append(indent()).append("} else {\n");
            out.append(indent()).append("  // Correctly handle first field printed without leading comma if it's optional and set\n");
            out.append(indent()).append("  // Or if it's the very first field overall.\n");
            out.append(indent()).append("}\n"); // This else block might be slightly off, testing will show.

            out.append(indent()).append("sb.append(\"").append(originalFieldName).append(":\");\n");

            if (typeCanBeNull(trueType)) {
                out.append(indent()).append("if (this.").append(originalFieldName).append(" == null) {\n");
                indentLevel++;
                out.append(indent()).append("sb.append(\"null\");\n");
                indentLevel--;
                out.append(indent()).append("} else {\n");
                indentLevel++;
                if (trueType.isBinary() && !trueType.isContainer()) {
                    out.append(indent()).append("org.apache.thrift.TBaseHelper.toString(this.").append(originalFieldName).append(", sb);\n");
                } else {
                    out.append(indent()).append("sb.append(this.").append(originalFieldName).append(");\n");
                }
                indentLevel--;
                out.append(indent()).append("}\n");
            } else {
                out.append(indent()).append("sb.append(this.").append(originalFieldName).append(");\n");
            }

            out.append(indent()).append("first = false;\n");

            if (isOptional) {
                indentLevel--;
                out.append(indent()).append("}\n");
            }
        }

        out.append(indent()).append("sb.append(\")\");\n");
        out.append(indent()).append("return sb.toString();\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");
    }

    private void generateJavaValidator(StructLikeNode struct) {
        out.append(indent()).append("public void validate() throws org.apache.thrift.TException {\n");
        indentLevel++;

        out.append(indent()).append("// check for required fields\n");
        for (FieldNode field : struct.getFields()) {
            if (field.getRequirement() == FieldNode.Requirement.REQUIRED) {
                String originalFieldName = field.getName();
                TypeNode fieldType = field.getType();
                String capName = capitalizedName(originalFieldName);
                TypeNode trueType = getTrueType(fieldType);

                if (beanStyle) {
                    out.append(indent()).append("if (!isSet").append(capName).append("()) {\n");
                    indentLevel++;
                    out.append(indent()).append("throw new org.apache.thrift.protocol.TProtocolException(\"Required field '")
                            .append(originalFieldName).append("' is unset! Struct: \" + toString());\n");
                    indentLevel--;
                    out.append(indent()).append("}\n");
                } else {
                    if (typeCanBeNull(trueType)) {
                        out.append(indent()).append("if (this.").append(originalFieldName).append(" == null) {\n");
                        indentLevel++;
                        out.append(indent()).append("throw new org.apache.thrift.protocol.TProtocolException(\"Required field '")
                                .append(originalFieldName).append("' was not present! Struct: \" + toString());\n");
                        indentLevel--;
                        out.append(indent()).append("}\n");
                    } else {
                        out.append(indent()).append("// alas, we cannot check '").append(originalFieldName)
                                .append("' because it's a primitive and you chose the non-beans generator.\n");
                    }
                }
            }
        }

        out.append(indent()).append("// check for sub-struct validity\n");
        for (FieldNode field : struct.getFields()) {
            String originalFieldName = field.getName();
            TypeNode originalTrueType = getTrueType(field.getType());
            if (originalTrueType.isStruct() || originalTrueType.isException()) {
                out.append(indent()).append("if (this.").append(originalFieldName).append(" != null) {\n");
                indentLevel++;
                out.append(indent()).append("((org.apache.thrift.TBase)this.").append(originalFieldName).append(").validate();\n");
                indentLevel--;
                out.append(indent()).append("}\n");
            }
        }

        indentLevel--;
        out.append(indent()).append("}\n\n");
    }

    private void generateJavaStructWriteObject(StructLikeNode struct) {
        out.append(indent()).append("private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {\n");
        indentLevel++;
        out.append(indent()).append("try {\n");
        indentLevel++;
        out.append(indent()).append("write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));\n");
        indentLevel--;
        out.append(indent()).append("} catch (org.apache.thrift.TException te) {\n");
        indentLevel++;
        if (androidLegacy) {
            out.append(indent()).append("throw new java.io.IOException(te.getMessage());\n");
        } else {
            out.append(indent()).append("throw new java.io.IOException(te);\n");
        }
        indentLevel--;
        out.append(indent()).append("}\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");
    }

    private void generateJavaStructReadObject(StructLikeNode struct) {
        out.append(indent()).append("private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException {\n");
        indentLevel++;
        out.append(indent()).append("try {\n");
        indentLevel++;

        int numFieldsActuallyNeedingIsset = getIssetHandledFieldCount();
        if (numFieldsActuallyNeedingIsset > 0) {
            IssetType issetStorageType = determineIssetStorageType(numFieldsActuallyNeedingIsset);
            if (issetStorageType == IssetType.PRIMITIVE) {
                out.append(indent()).append("// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.\n");
                out.append(indent()).append("__isset_bitfield = 0;\n");
            } else if (issetStorageType == IssetType.BITSET) {
                out.append(indent()).append("// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.\n");
                out.append(indent()).append("__isset_bit_vector = new java.util.BitSet(").append(numFieldsActuallyNeedingIsset).append(");\n");
            }
        }

        out.append(indent()).append("read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));\n");
        indentLevel--;
        out.append(indent()).append("} catch (org.apache.thrift.TException te) {\n");
        indentLevel++;
        if (androidLegacy) {
            out.append(indent()).append("throw new java.io.IOException(te.getMessage());\n");
        } else {
            out.append(indent()).append("throw new java.io.IOException(te);\n");
        }
        indentLevel--;
        out.append(indent()).append("}\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");
    }


    private void generateJavaStructStandardScheme(StructLikeNode structNode, boolean isResult) {
        String structName = getEffectiveJavaIdentifier(structNode.getName());
        String capStructName = capitalizedName(structName);

        out.append(indent()).append("private static class ").append(capStructName).append("StandardSchemeFactory implements org.apache.thrift.scheme.SchemeFactory {\n");
        indentLevel++;
        out.append(indent()).append(javaOverrideAnnotation()).append("\n");
        out.append(indent()).append("public ").append(capStructName).append("StandardScheme getScheme() {\n");
        indentLevel++;
        out.append(indent()).append("return new ").append(capStructName).append("StandardScheme();\n");
        indentLevel--;
        out.append(indent()).append("}\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");

        out.append(indent()).append("private static class ").append(capStructName).append("StandardScheme extends org.apache.thrift.scheme.StandardScheme<").append(structName).append("> {\n\n");
        indentLevel++;

        out.append(indent()).append(javaOverrideAnnotation()).append("\n");
        out.append(indent()).append("public void read(org.apache.thrift.protocol.TProtocol iprot, ").append(structName).append(" struct) throws org.apache.thrift.TException {\n");
        indentLevel++;
        out.append(indent()).append("org.apache.thrift.protocol.TField schemeField;\n");
        out.append(indent()).append("iprot.readStructBegin();\n");
        out.append(indent()).append("while (true)\n");
        out.append(indent()).append("{\n");
        indentLevel++;
        out.append(indent()).append("schemeField = iprot.readFieldBegin();\n");
        out.append(indent()).append("if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { \n");
        indentLevel++;
        out.append(indent()).append("break;\n");
        indentLevel--;
        out.append(indent()).append("}\n");
        out.append(indent()).append("switch (schemeField.id) {\n");
        for (FieldNode field : structNode.getFields()) {
            String originalFieldName = field.getName();
            String fieldConstName = constantName(originalFieldName).toUpperCase();
            indentLevel++;
            out.append(indent()).append("case ").append(field.getId()).append(": // ").append(fieldConstName).append("\n");
            indentLevel++;
            out.append(indent()).append("if (schemeField.type == ").append(typeToEnum(field.getType())).append(") {\n");
            indentLevel++;
            generateStandardSchemeDeserializerLogic(field, "struct");
            out.append(indent()).append("struct.set").append(capitalizedName(originalFieldName)).append("IsSet(true);\n");
            indentLevel--;
            out.append(indent()).append("} else { \n");
            indentLevel++;
            out.append(indent()).append("org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);\n");
            indentLevel--;
            out.append(indent()).append("}\n");
            out.append(indent()).append("break;\n");
            indentLevel--;
            indentLevel--;
        }
        out.append(indent()).append("  default:\n");
        indentLevel++;
        out.append(indent()).append("org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);\n");
        indentLevel--;
        out.append(indent()).append("}\n");
        out.append(indent()).append("iprot.readFieldEnd();\n");
        indentLevel--;
        out.append(indent()).append("}\n");
        out.append(indent()).append("iprot.readStructEnd();\n");

        if (!beanStyle) {
            out.append(indent()).append("// check for required fields of primitive type, which can't be checked in the validate method\n");
            for (FieldNode field : structNode.getFields()) {
                TypeNode fieldType = field.getType();
                if (field.getRequirement() == FieldNode.Requirement.REQUIRED && isPrimitiveType(getTrueType(fieldType))) { // Use getTrueType here
                    out.append(indent()).append("if (!struct.isSet").append(capitalizedName(field.getName())).append("()) {\n");
                    indentLevel++;
                    out.append(indent()).append("throw new org.apache.thrift.protocol.TProtocolException(\"Required field '")
                            .append(field.getName()).append("' was not found in serialized data! Struct: \" + struct.toString());\n");
                    indentLevel--;
                    out.append(indent()).append("}\n");
                }
            }
        }
        out.append(indent()).append("struct.validate();\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");

        out.append(indent()).append(javaOverrideAnnotation()).append("\n");
        out.append(indent()).append("public void write(org.apache.thrift.protocol.TProtocol oprot, ").append(structName).append(" struct) throws org.apache.thrift.TException {\n");
        indentLevel++;
        out.append(indent()).append("struct.validate();\n\n");
        out.append(indent()).append("oprot.writeStructBegin(STRUCT_DESC);\n");

        List<FieldNode> sortedFields = new ArrayList<>(structNode.getFields());
        java.util.Collections.sort(sortedFields, java.util.Comparator.comparingInt(FieldNode::getId));

        for (FieldNode field : sortedFields) {
            String originalFieldName = field.getName();
            String capFieldName = capitalizedName(originalFieldName);
            TypeNode fieldType = field.getType();

            boolean isOptionalField = field.getRequirement() == FieldNode.Requirement.OPTIONAL;
            boolean isNullable = typeCanBeNull(fieldType);

            if (isOptionalField) {
                out.append(indent()).append("if (struct.isSet").append(capFieldName).append("()) {\n");
                indentLevel++;
            } else if (isNullable) {
                 out.append(indent()).append("if (struct.").append(originalFieldName).append(" != null) {\n");
                 indentLevel++;
            }

            out.append(indent()).append("oprot.writeFieldBegin(").append(constantName(originalFieldName).toUpperCase()).append("_FIELD_DESC);\n");
            generateStandardSchemeSerializerLogic(field, "struct");
            out.append(indent()).append("oprot.writeFieldEnd();\n");

            if (isOptionalField || (isNullable && !isOptionalField)) {
                indentLevel--;
                out.append(indent()).append("}\n");
            }
        }
        out.append(indent()).append("oprot.writeFieldStop();\n");
        out.append(indent()).append("oprot.writeStructEnd();\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");

        indentLevel--;
        out.append(indent()).append("}\n\n");
    }

    private void generateJavaStructTupleScheme(StructLikeNode structNode) {
        String structName = getEffectiveJavaIdentifier(structNode.getName());
        String capStructName = capitalizedName(structName);

        out.append(indent()).append("private static class ").append(capStructName).append("TupleSchemeFactory implements org.apache.thrift.scheme.SchemeFactory {\n");
        indentLevel++;
        out.append(indent()).append(javaOverrideAnnotation()).append("\n");
        out.append(indent()).append("public ").append(capStructName).append("TupleScheme getScheme() {\n");
        indentLevel++;
        out.append(indent()).append("return new ").append(capStructName).append("TupleScheme();\n");
        indentLevel--;
        out.append(indent()).append("}\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");

        out.append(indent()).append("private static class ").append(capStructName).append("TupleScheme extends org.apache.thrift.scheme.TupleScheme<").append(structName).append("> {\n");
        indentLevel++;

        out.append(indent()).append(javaOverrideAnnotation()).append("\n");
        out.append(indent()).append("@SuppressWarnings(\"unchecked\")\n");
        out.append(indent()).append("public void write(org.apache.thrift.protocol.TProtocol prot, ").append(structName).append(" struct) throws org.apache.thrift.TException {\n");
        indentLevel++;
        out.append(indent()).append("org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;\n");

        List<FieldNode> optionalFields = new ArrayList<>();
        List<FieldNode> requiredOrDefFields = new ArrayList<>();

        // Populate and sort fields by ID for canonical order
        List<FieldNode> allFieldsSorted = new ArrayList<>(structNode.getFields());
        java.util.Collections.sort(allFieldsSorted, java.util.Comparator.comparingInt(FieldNode::getId));

        for (FieldNode field : allFieldsSorted) {
            if (field.getRequirement() == FieldNode.Requirement.OPTIONAL) {
                optionalFields.add(field); // optionalFields will maintain ID-sorted order from allFieldsSorted
            } else {
                requiredOrDefFields.add(field); // requiredOrDefFields will maintain ID-sorted order
            }
        }

        for (FieldNode field : requiredOrDefFields) { // Already sorted by ID
            generateTupleSchemeSerializerLogic(field, "struct", "oprot");
        }

        if (!optionalFields.isEmpty()) {
            out.append(indent()).append("java.util.BitSet optionals = new java.util.BitSet();\n");
            // Optional fields are already sorted by ID in optionalFields list.
            // The bitset index corresponds to the position in this sorted list.
            for (int i = 0; i < optionalFields.size(); i++) {
                FieldNode field = optionalFields.get(i);
                String originalFieldName = field.getName();
                out.append(indent()).append("if (struct.isSet").append(capitalizedName(originalFieldName)).append("()) {\n");
                indentLevel++;
                out.append(indent()).append("optionals.set(").append(i).append(");\n");
                indentLevel--;
                out.append(indent()).append("}\n");
            }
            out.append(indent()).append("oprot.writeBitSet(optionals, ").append(optionalFields.size()).append(");\n");
            for (FieldNode field : optionalFields) { // Already sorted by ID
                String originalFieldName = field.getName();
                out.append(indent()).append("if (struct.isSet").append(capitalizedName(originalFieldName)).append("()) {\n");
                indentLevel++;
                generateTupleSchemeSerializerLogic(field, "struct", "oprot");
                indentLevel--;
                out.append(indent()).append("}\n");
            }
        }
        indentLevel--;
        out.append(indent()).append("}\n\n");

        out.append(indent()).append(javaOverrideAnnotation()).append("\n");
        out.append(indent()).append("public void read(org.apache.thrift.protocol.TProtocol prot, ").append(structName).append(" struct) throws org.apache.thrift.TException {\n");
        indentLevel++;
        out.append(indent()).append("org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;\n");

        optionalFields.clear();
        requiredOrDefFields.clear();
        for (FieldNode field : structNode.getFields()) {
            if (field.getRequirement() == FieldNode.Requirement.OPTIONAL) {
                optionalFields.add(field);
            } else {
                requiredOrDefFields.add(field);
            }
        }

        for (FieldNode field : requiredOrDefFields) {
            String originalFieldName = field.getName();
            generateStandardSchemeDeserializerLogic(field, "struct", "iprot");
            out.append(indent()).append("struct.set").append(capitalizedName(originalFieldName)).append("IsSet(true);\n");
        }

        if (!optionalFields.isEmpty()) {
            out.append(indent()).append("java.util.BitSet incoming = iprot.readBitSet(").append(optionalFields.size()).append(");\n");
            for (int i = 0; i < optionalFields.size(); i++) {
                FieldNode field = optionalFields.get(i);
                String originalFieldName = field.getName();
                out.append(indent()).append("if (incoming.get(").append(i).append(")) {\n");
                indentLevel++;
                generateStandardSchemeDeserializerLogic(field, "struct", "iprot");
                out.append(indent()).append("struct.set").append(capitalizedName(originalFieldName)).append("IsSet(true);\n");
                indentLevel--;
                out.append(indent()).append("}\n");
            }
        }
        indentLevel--;
        out.append(indent()).append("}\n");

        indentLevel--;
        out.append(indent()).append("}\n\n");
    }

    // New method for TupleScheme serialization (no metadata like Begin/End for containers)
    private void generateTupleSchemeSerializerLogic(FieldNode field, String structVarName, String protVarName) {
        TypeNode fieldType = field.getType();
        String originalFieldName = field.getName();
        // For tuple scheme, protVarName is already cast to TTupleProtocol (e.g. "oprot")
        // So, direct calls like oprot.writeI32(), oprot.writeString() are fine.
        TypeNode trueType = getTrueType(fieldType);

        if (trueType.isBaseType()) {
            String baseName = trueType.getName();
            if (trueType.isBinary()) baseName = "binary";

            switch (baseName) {
                case "bool": out.append(indent()).append(protVarName).append(".writeBool(").append(structVarName).append(".").append(originalFieldName).append(");\n"); break;
                case "byte": case "i8": out.append(indent()).append(protVarName).append(".writeByte(").append(structVarName).append(".").append(originalFieldName).append(");\n"); break;
                case "i16": out.append(indent()).append(protVarName).append(".writeI16(").append(structVarName).append(".").append(originalFieldName).append(");\n"); break;
                case "i32": out.append(indent()).append(protVarName).append(".writeI32(").append(structVarName).append(".").append(originalFieldName).append(");\n"); break;
                case "i64": out.append(indent()).append(protVarName).append(".writeI64(").append(structVarName).append(".").append(originalFieldName).append(");\n"); break;
                case "double": out.append(indent()).append(protVarName).append(".writeDouble(").append(structVarName).append(".").append(originalFieldName).append(");\n"); break;
                case "string": out.append(indent()).append(protVarName).append(".writeString(").append(structVarName).append(".").append(originalFieldName).append(");\n"); break;
                case "binary": out.append(indent()).append(protVarName).append(".writeBinary(").append(structVarName).append(".").append(originalFieldName).append(");\n"); break;
                case "uuid": out.append(indent()).append(protVarName).append(".writeUuid(").append(structVarName).append(".").append(originalFieldName).append(");\n"); break;
                default: throw new RuntimeException("Unhandled base type for tuple serialization: " + baseName);
            }
        } else if (trueType.isEnum()) {
            out.append(indent()).append(protVarName).append(".writeI32(").append(structVarName).append(".").append(originalFieldName).append(".getValue());\n");
        } else if (trueType.isStruct() || trueType.isException()) {
            out.append(indent()).append(structVarName).append(".").append(originalFieldName).append(".write(").append(protVarName).append(");\n"); // Structs handle their own tuple/standard switching
        } else if (trueType.isContainer()) {
            serializeTupleContainer(trueType, originalFieldName, structVarName, protVarName);
        } else {
            throw new RuntimeException("Unhandled type for tuple serialization: " + trueType.getName());
        }
    }

    private void generateStandardSchemeDeserializerLogic(FieldNode field, String structVarName) {
        generateStandardSchemeDeserializerLogic(field, structVarName, "iprot");
    }

    private void generateStandardSchemeDeserializerLogic(FieldNode field, String structVarName, String protVarName) {
        TypeNode fieldType = field.getType();
        String originalFieldName = field.getName();
        TypeNode trueType = getTrueType(fieldType);

        if (trueType.isBaseType()) {
            String baseName = trueType.getName();
            if (trueType.isBinary()) baseName = "binary";

            switch (baseName) {
                case "bool": out.append(indent()).append(structVarName).append(".").append(originalFieldName).append(" = ").append(protVarName).append(".readBool();\n"); break;
                case "byte": case "i8": out.append(indent()).append(structVarName).append(".").append(originalFieldName).append(" = ").append(protVarName).append(".readByte();\n"); break;
                case "i16": out.append(indent()).append(structVarName).append(".").append(originalFieldName).append(" = ").append(protVarName).append(".readI16();\n"); break;
                case "i32": out.append(indent()).append(structVarName).append(".").append(originalFieldName).append(" = ").append(protVarName).append(".readI32();\n"); break;
                case "i64": out.append(indent()).append(structVarName).append(".").append(originalFieldName).append(" = ").append(protVarName).append(".readI64();\n"); break;
                case "double": out.append(indent()).append(structVarName).append(".").append(originalFieldName).append(" = ").append(protVarName).append(".readDouble();\n"); break;
                case "string": out.append(indent()).append(structVarName).append(".").append(originalFieldName).append(" = ").append(protVarName).append(".readString();\n"); break;
                case "binary": out.append(indent()).append(structVarName).append(".").append(originalFieldName).append(" = ").append(protVarName).append(".readBinary();\n"); break;
                case "uuid": out.append(indent()).append(structVarName).append(".").append(originalFieldName).append(" = ").append(protVarName).append(".readUuid();\n"); break;
                default: throw new RuntimeException("Unhandled base type for deserialization: " + baseName);
            }
        } else if (trueType.isEnum()) {
            out.append(indent()).append(structVarName).append(".").append(originalFieldName).append(" = ").append(getTypeName(trueType)).append(".findByValue(").append(protVarName).append(".readI32());\n");
        } else if (trueType.isStruct() || trueType.isException()) {
            out.append(indent()).append(structVarName).append(".").append(originalFieldName).append(" = new ").append(getTypeName(trueType)).append("();\n");
            out.append(indent()).append(structVarName).append(".").append(originalFieldName).append(".read(").append(protVarName).append(");\n");
        } else if (trueType.isContainer()) {
            deserializeContainer(trueType, originalFieldName, structVarName, protVarName); // StandardScheme read uses this
        } else {
            throw new RuntimeException("Unhandled type for deserialization: " + trueType.getName());
        }
    }

    private void generateStandardSchemeSerializerLogic(FieldNode field, String structVarName) {
        generateStandardSchemeSerializerLogic(field, structVarName, "oprot");
    }

    private void generateStandardSchemeSerializerLogic(FieldNode field, String structVarName, String protVarName) {
        TypeNode fieldType = field.getType();
        String originalFieldName = field.getName();
        TypeNode trueType = getTrueType(fieldType);

        if (trueType.isBaseType()) {
            String baseName = trueType.getName();
            if (trueType.isBinary()) baseName = "binary";

            switch (baseName) {
                case "bool": out.append(indent()).append(protVarName).append(".writeBool(").append(structVarName).append(".").append(originalFieldName).append(");\n"); break;
                case "byte": case "i8": out.append(indent()).append(protVarName).append(".writeByte(").append(structVarName).append(".").append(originalFieldName).append(");\n"); break;
                case "i16": out.append(indent()).append(protVarName).append(".writeI16(").append(structVarName).append(".").append(originalFieldName).append(");\n"); break;
                case "i32": out.append(indent()).append(protVarName).append(".writeI32(").append(structVarName).append(".").append(originalFieldName).append(");\n"); break;
                case "i64": out.append(indent()).append(protVarName).append(".writeI64(").append(structVarName).append(".").append(originalFieldName).append(");\n"); break;
                case "double": out.append(indent()).append(protVarName).append(".writeDouble(").append(structVarName).append(".").append(originalFieldName).append(");\n"); break;
                case "string": out.append(indent()).append(protVarName).append(".writeString(").append(structVarName).append(".").append(originalFieldName).append(");\n"); break;
                case "binary": out.append(indent()).append(protVarName).append(".writeBinary(").append(structVarName).append(".").append(originalFieldName).append(");\n"); break;
                case "uuid": out.append(indent()).append(protVarName).append(".writeUuid(").append(structVarName).append(".").append(originalFieldName).append(");\n"); break;
                default: throw new RuntimeException("Unhandled base type for serialization: " + baseName);
            }
        } else if (trueType.isEnum()) {
            out.append(indent()).append(protVarName).append(".writeI32(").append(structVarName).append(".").append(originalFieldName).append(".getValue());\n");
        } else if (trueType.isStruct() || trueType.isException()) {
            out.append(indent()).append(structVarName).append(".").append(originalFieldName).append(".write(").append(protVarName).append(");\n");
        } else if (trueType.isContainer()) {
            serializeContainer(trueType, originalFieldName, structVarName, protVarName); // StandardScheme write uses this
        } else {
            throw new RuntimeException("Unhandled type for serialization: " + trueType.getName());
        }
    }

    // Helper for StandardScheme deserialization of containers
    private void deserializeContainer(TypeNode containerType, String fieldJavaName, String structVarName, String protVarName) {
        scope_up();

        String tempObj = ""; // Renamed from obj to avoid conflict with parameter 'obj' if any
        if (containerType.isMap()) {
            tempObj = getNextTempVarName("_map");
        } else if (containerType.isSet()) {
            tempObj = getNextTempVarName("_set");
        } else if (containerType.isList()) {
            tempObj = getNextTempVarName("_list");
        }

        // Declare variables, read header
        if (containerType.isMap()) {
            out.append(indent()).append("org.apache.thrift.protocol.TMap ").append(tempObj).append(" = ")
                    .append(protVarName).append(".readMapBegin();\n");
        } else if (containerType.isSet()) {
            out.append(indent()).append("org.apache.thrift.protocol.TSet ").append(tempObj).append(" = ")
                    .append(protVarName).append(".readSetBegin();\n");
        } else if (containerType.isList()) {
            out.append(indent()).append("org.apache.thrift.protocol.TList ").append(tempObj).append(" = ")
                    .append(protVarName).append(".readListBegin();\n");
        }

        // Initialize the collection
        String initTypeName = getTypeName(containerType, false, true, false, false);
        if (containerType.isMap()) {
            if (initTypeName.startsWith("java.util.EnumMap")) {
                TypeNode keyType = getTrueType(containerType.getChildNodes().get(0));
                out.append(indent()).append(structVarName).append(".").append(fieldJavaName)
                        .append(" = new ").append(initTypeName).append("(")
                        .append(getTypeName(keyType, true, false, true, true)).append(");\n");
            } else {
                out.append(indent()).append(structVarName).append(".").append(fieldJavaName)
                        .append(" = new ").append(initTypeName).append("(2*").append(tempObj).append(".size);\n");
            }

            // Deserialize map elements
            String tmpKeyVar = getNextTempVarName("_key");
            String tmpValVar = getNextTempVarName("_val");
            TypeNode keyType = getTrueType(containerType.getChildNodes().get(0));
            TypeNode valType = getTrueType(containerType.getChildNodes().get(1));

            out.append(indent()).append(getTypeName(keyType, true, false, false, true))
                    .append(" ").append(tmpKeyVar).append(";\n");
            out.append(indent()).append(getTypeName(valType, true, false, false, true))
                    .append(" ").append(tmpValVar).append(";\n");

            out.append(indent()).append("for (int _i = 0; _i < ").append(tempObj).append(".size; ++_i)\n");
            out.append(indent()).append("{\n");
            indentLevel++;

            generateStandardSchemeDeserializerLogic(new FieldNode(keyType, tmpKeyVar), "", protVarName); // Uses standard deserializer for elements
            generateStandardSchemeDeserializerLogic(new FieldNode(valType, tmpValVar), "", protVarName); // Uses standard deserializer for elements

            boolean isKeyEnum = getTrueType(keyType).isEnum();
            if (isKeyEnum) {
                out.append(indent()).append("if (").append(tmpKeyVar).append(" != null) {\n");
                indentLevel++;
            }

            out.append(indent()).append(structVarName).append(".").append(fieldJavaName)
                    .append(".put(").append(tmpKeyVar).append(", ").append(tmpValVar).append(");\n");

            if (isKeyEnum) {
                indentLevel--;
                out.append(indent()).append("}\n");
            }

            indentLevel--;
            out.append(indent()).append("}\n");

        } else if (containerType.isSet()) {
            TypeNode elemType = getTrueType(containerType.getChildNodes().get(0));
            if (initTypeName.startsWith("java.util.EnumSet")) {
                out.append(indent()).append(structVarName).append(".").append(fieldJavaName)
                        .append(" = ").append(initTypeName).append(".noneOf(")
                        .append(getTypeName(elemType, true, false, true, true)).append(");\n");
            } else {
                out.append(indent()).append(structVarName).append(".").append(fieldJavaName)
                        .append(" = new ").append(initTypeName).append("(").append(tempObj).append(".size);\n");
            }

            // Deserialize set elements
            String tmpElemVar = getNextTempVarName("_elem");
            out.append(indent()).append(getTypeName(elemType, true, false, false, true))
                    .append(" ").append(tmpElemVar).append(";\n");

            out.append(indent()).append("for (int _i = 0; _i < ").append(tempObj).append(".size; ++_i)\n");
            out.append(indent()).append("{\n");
            indentLevel++;

            generateStandardSchemeDeserializerLogic(new FieldNode(elemType, tmpElemVar), "", protVarName);  // Uses standard deserializer for elements
            generateStandardSchemeDeserializerLogic(new FieldNode(elemType, tmpElemVar), "", protVarName); // Uses standard deserializer for elements

            boolean isElemEnum = getTrueType(elemType).isEnum();
            if (isElemEnum) {
                out.append(indent()).append("if (").append(tmpElemVar).append(" != null) {\n");
                indentLevel++;
            }

            out.append(indent()).append(structVarName).append(".").append(fieldJavaName)
                    .append(".add(").append(tmpElemVar).append(");\n");

            if (isElemEnum) {
                indentLevel--;
                out.append(indent()).append("}\n");
            }

            indentLevel--;
            out.append(indent()).append("}\n");

        } else if (containerType.isList()) {
            TypeNode elemType = getTrueType(containerType.getChildNodes().get(0));
            out.append(indent()).append(structVarName).append(".").append(fieldJavaName)
                    .append(" = new ").append(initTypeName).append("(").append(tempObj).append(".size);\n");

            // Deserialize list elements
            String tmpElemVar = getNextTempVarName("_elem");
            out.append(indent()).append(getTypeName(elemType, true, false, false, true))
                    .append(" ").append(tmpElemVar).append(";\n");

            out.append(indent()).append("for (int _i = 0; _i < ").append(tempObj).append(".size; ++_i)\n");
            out.append(indent()).append("{\n");
            indentLevel++;

            generateStandardSchemeDeserializerLogic(new FieldNode(elemType, tmpElemVar), "", protVarName);

            boolean isElemEnum = getTrueType(elemType).isEnum();
            if (isElemEnum) {
                out.append(indent()).append("if (").append(tmpElemVar).append(" != null) {\n");
                indentLevel++;
            }

            out.append(indent()).append(structVarName).append(".").append(fieldJavaName)
                    .append(".add(").append(tmpElemVar).append(");\n");

            if (isElemEnum) {
                indentLevel--;
                out.append(indent()).append("}\n");
            }

            indentLevel--;
            out.append(indent()).append("}\n");
        } else {
            throw new RuntimeException("Unknown container type for deserialization: " + containerType.getName());
        }

        // Read container end
        if (containerType.isMap()) {
            out.append(indent()).append(protVarName).append(".readMapEnd();\n");
        } else if (containerType.isSet()) {
            out.append(indent()).append(protVarName).append(".readSetEnd();\n");
        } else if (containerType.isList()) {
            out.append(indent()).append(protVarName).append(".readListEnd();\n");
        }

        scope_down();
    }

    private void serializeContainer(TypeNode containerType, String fieldJavaName, String structVarName, String protVarName) {
        String tempIterVar = getNextTempVarName("_iter");
        if (containerType.isList()) {
            TypeNode elemType = getTrueType(containerType.getChildNodes().get(0));
            out.append(indent()).append(protVarName).append(".writeListBegin(new org.apache.thrift.protocol.TList(").append(typeToEnum(elemType)).append(", ").append(structVarName).append(".").append(fieldJavaName).append(".size()));\n");
            out.append(indent()).append("for (").append(getTypeName(elemType, true, false, false, true)).append(" ").append(tempIterVar).append(" : ").append(structVarName).append(".").append(fieldJavaName).append(")\n");
            out.append(indent()).append("{\n");
            indentLevel++;
            generateStandardSchemeSerializerLogic(new FieldNode(elemType, tempIterVar), "", protVarName); // StandardScheme write uses this
            indentLevel--;
            out.append(indent()).append("}\n");
            out.append(indent()).append(protVarName).append(".writeListEnd();\n");
        } else if (containerType.isSet()) {
            TypeNode elemType = getTrueType(containerType.getChildNodes().get(0));
            out.append(indent()).append(protVarName).append(".writeSetBegin(new org.apache.thrift.protocol.TSet(").append(typeToEnum(elemType)).append(", ").append(structVarName).append(".").append(fieldJavaName).append(".size()));\n");
            out.append(indent()).append("for (").append(getTypeName(elemType, true, false, false, true)).append(" ").append(tempIterVar).append(" : ").append(structVarName).append(".").append(fieldJavaName).append(")\n");
            out.append(indent()).append("{\n");
            indentLevel++;
            generateStandardSchemeSerializerLogic(new FieldNode(elemType, tempIterVar), "", protVarName); // StandardScheme write uses this
            indentLevel--;
            out.append(indent()).append("}\n");
            out.append(indent()).append(protVarName).append(".writeSetEnd();\n");
        } else if (containerType.isMap()) {
            TypeNode keyType = getTrueType(containerType.getChildNodes().get(0));
            TypeNode valType = getTrueType(containerType.getChildNodes().get(1));
            out.append(indent()).append(protVarName).append(".writeMapBegin(new org.apache.thrift.protocol.TMap(").append(typeToEnum(keyType)).append(", ").append(typeToEnum(valType)).append(", ").append(structVarName).append(".").append(fieldJavaName).append(".size()));\n");
            out.append(indent()).append("for (java.util.Map.Entry<").append(getTypeName(keyType, true, false, false, true)).append(", ").append(getTypeName(valType, true, false, false, true)).append("> ").append(tempIterVar).append(" : ").append(structVarName).append(".").append(fieldJavaName).append(".entrySet())\n");
            out.append(indent()).append("{\n");
            indentLevel++;
            generateStandardSchemeSerializerLogic(new FieldNode(keyType, tempIterVar + ".getKey()"), "", protVarName); // StandardScheme write uses this
            generateStandardSchemeSerializerLogic(new FieldNode(valType, tempIterVar + ".getValue()"), "", protVarName); // StandardScheme write uses this
            indentLevel--;
            out.append(indent()).append("}\n");
            out.append(indent()).append(protVarName).append(".writeMapEnd();\n");
        } else {
            throw new RuntimeException("Unknown container type for serialization: " + containerType.getName());
        }
    }

    // Helper for TupleScheme serialization of containers
    private void serializeTupleContainer(TypeNode containerType, String fieldJavaName, String structVarName, String protVarName) {
        // protVarName is already cast to TTupleProtocol (e.g. "oprot")
        String tempIterVar = getNextTempVarName("_iter");
        if (containerType.isList()) {
            TypeNode elemType = getTrueType(containerType.getChildNodes().get(0));
            out.append(indent()).append(protVarName).append(".writeI32(").append(structVarName).append(".").append(fieldJavaName).append(".size());\n");
            out.append(indent()).append("for (").append(getTypeName(elemType, true, false, false, true)).append(" ").append(tempIterVar).append(" : ").append(structVarName).append(".").append(fieldJavaName).append(")\n");
            out.append(indent()).append("{\n");
            indentLevel++;
            generateTupleSchemeSerializerLogic(new FieldNode(elemType, tempIterVar), "", protVarName);
            indentLevel--;
            out.append(indent()).append("}\n");
        } else if (containerType.isSet()) {
            TypeNode elemType = getTrueType(containerType.getChildNodes().get(0));
            out.append(indent()).append(protVarName).append(".writeI32(").append(structVarName).append(".").append(fieldJavaName).append(".size());\n");
            out.append(indent()).append("for (").append(getTypeName(elemType, true, false, false, true)).append(" ").append(tempIterVar).append(" : ").append(structVarName).append(".").append(fieldJavaName).append(")\n");
            out.append(indent()).append("{\n");
            indentLevel++;
            generateTupleSchemeSerializerLogic(new FieldNode(elemType, tempIterVar), "", protVarName);
            indentLevel--;
            out.append(indent()).append("}\n");
        } else if (containerType.isMap()) {
            TypeNode keyType = getTrueType(containerType.getChildNodes().get(0));
            TypeNode valType = getTrueType(containerType.getChildNodes().get(1));
            out.append(indent()).append(protVarName).append(".writeI32(").append(structVarName).append(".").append(fieldJavaName).append(".size());\n");
            out.append(indent()).append("for (java.util.Map.Entry<").append(getTypeName(keyType, true, false, false, true)).append(", ").append(getTypeName(valType, true, false, false, true)).append("> ").append(tempIterVar).append(" : ").append(structVarName).append(".").append(fieldJavaName).append(".entrySet())\n");
            out.append(indent()).append("{\n");
            indentLevel++;
            generateTupleSchemeSerializerLogic(new FieldNode(keyType, tempIterVar + ".getKey()"), "", protVarName);
            generateTupleSchemeSerializerLogic(new FieldNode(valType, tempIterVar + ".getValue()"), "", protVarName);
            indentLevel--;
            out.append(indent()).append("}\n");
        } else {
            throw new RuntimeException("Unknown container type for tuple serialization: " + containerType.getName());
        }
    }

    private void generateJavaSchemeLookup() {
        out.append(indent()).append("private static <S extends org.apache.thrift.scheme.IScheme> S scheme(")
                .append("org.apache.thrift.protocol.TProtocol proto) {\n");
        indentLevel++;

        out.append(indent()).append("return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ")
                .append("? STANDARD_SCHEME_FACTORY ")
                .append(": TUPLE_SCHEME_FACTORY")
                .append(").getScheme();\n");

        indentLevel--;
        out.append(indent()).append("}\n");
    }

    private void generateJavaStructParcelable(StructLikeNode struct) {
        out.append(indent()).append("// TODO: Generate Android Parcelable implementation\n");
    }

    private void generateJavaDoc(StructLikeNode node) {
    }

    private void generateJavaDoc(FieldNode node) {
    }

    private void generateJavaxGeneratedAnnotation() {
        String summary = getAutogenSummary();
        if (jakartaAnnotations) {
            out.append(indent()).append("@jakarta.annotation.Generated(value = \"").append(summary).append("\"");
        } else {
            out.append(indent()).append("@javax.annotation.Generated(value = \"").append(summary).append("\"");
        }

        if (undatedGeneratedAnnotations) {
            out.append(")\n");
        } else {
            out.append(", date = \"").append(this.date).append("\")\n");
        }
    }

    private String getJavaSuppressWarnings() {
        return "@SuppressWarnings({\"cast\", \"rawtypes\", \"serial\", \"unchecked\", \"unused\"})";
    }

    private String getAutogenSummary() {
        return "Autogenerated by Thrift Compiler (0.20.0)";
    }

    private String javaOverrideAnnotation() {
        return "@Override";
    }

    private String javaNullableAnnotation() {
        return "@org.apache.thrift.annotation.Nullable";
    }

    private String constantName(String name) {
        StringBuilder constantName = new StringBuilder();
        boolean isFirst = true;
        boolean wasPreviousCharUpper = false;
        for (char c : name.toCharArray()) {
            boolean isUpper = Character.isUpperCase(c);
            if (isUpper && !isFirst && !wasPreviousCharUpper) {
                constantName.append('_');
            }
            constantName.append(Character.toUpperCase(c));
            isFirst = false;
            wasPreviousCharUpper = isUpper;
        }
        return constantName.toString();
    }

    private String issetFieldId(FieldNode field) {
        String originalFieldName = field.getName();
        return "__" + constantName(originalFieldName).toUpperCase() + "_ISSET_ID";
    }

    private boolean fieldNeedsIssetHandling(FieldNode field) {
        TypeNode trueType = getTrueType(field.getType());
        if (field.getRequirement() == FieldNode.Requirement.OPTIONAL) {
            return !typeCanBeNull(trueType);
        }
        if (!typeCanBeNull(trueType) && !this.beanStyle) {
            return true;
        }
        return false;
    }

    private int getIssetHandledFieldCount() {
        int count = 0;
        if (this.structLikeNode != null && this.structLikeNode.getFields() != null) {
            for (FieldNode f : this.structLikeNode.getFields()) {
                if (fieldNeedsIssetHandling(f)) {
                    count++;
                }
            }
        }
        return count;
    }

    private IssetType determineIssetStorageType(int numberOfFieldsNeedingIssetBits) {
        if (numberOfFieldsNeedingIssetBits == 0) return IssetType.NONE;
        if (numberOfFieldsNeedingIssetBits <= 64) return IssetType.PRIMITIVE;
        return IssetType.BITSET;
    }

    private String determinePrimitiveTypeForIsset(int numberOfFieldsNeedingIssetBits) {
        if (numberOfFieldsNeedingIssetBits <= 0) return "byte";
        if (numberOfFieldsNeedingIssetBits <= 8) return "byte";
        if (numberOfFieldsNeedingIssetBits <= 16) return "short";
        if (numberOfFieldsNeedingIssetBits <= 32) return "int";
        return "long";
    }

    private boolean typeCanBeNull(TypeNode type) {
        TypeNode trueType = getTrueType(type);
        if (trueType.isContainer() || trueType.isStruct() || trueType.isException() || trueType.isEnum()) {
            return true;
        }
        if (trueType.isBaseType()) {
            return "string".equals(trueType.getName()) ||
                    "uuid".equals(trueType.getName()) ||
                    trueType.isBinary();
        }
        return false;
    }

    private boolean isPrimitiveType(TypeNode type) {
        TypeNode trueType = getTrueType(type);
        if (trueType.isBaseType()) {
            String baseName = trueType.getName();
            switch (baseName) {
                case "bool": case "byte": case "i8": case "i16":
                case "i32": case "i64": case "double":
                    return true;
                case "string": case "binary": case "uuid":
                    return false;
                default:
                    return false;
            }
        }
        return false;
    }

    private String typeToEnum(TypeNode type) {
        TypeNode trueType = getTrueType(type);

        if (trueType.isBaseType()) {
            String baseName = trueType.getName();
            if (trueType.isBinary() || "binary".equals(baseName)) {
                return "org.apache.thrift.protocol.TType.STRING";
            }
            switch (baseName) {
                case "void": return "org.apache.thrift.protocol.TType.VOID";
                case "string": return "org.apache.thrift.protocol.TType.STRING";
                case "bool": return "org.apache.thrift.protocol.TType.BOOL";
                case "byte":
                case "i8": return "org.apache.thrift.protocol.TType.BYTE";
                case "i16": return "org.apache.thrift.protocol.TType.I16";
                case "i32": return "org.apache.thrift.protocol.TType.I32";
                case "i64": return "org.apache.thrift.protocol.TType.I64";
                case "uuid": return "org.apache.thrift.protocol.TType.UUID";
                case "double": return "org.apache.thrift.protocol.TType.DOUBLE";
                default:
                    if (trueType instanceof BaseTypeNode && ((BaseTypeNode)trueType).getType() == BaseTypeNode.BaseTypeEnum.BYTE) {
                        return "org.apache.thrift.protocol.TType.BYTE";
                    }
                    throw new RuntimeException("Unknown base type for TType enum: " + baseName);
            }
        } else if (trueType.isEnum()) {
            return "org.apache.thrift.protocol.TType.I32";
        } else if (trueType.isStruct() || trueType.isException()) {
            return "org.apache.thrift.protocol.TType.STRUCT";
        } else if (trueType.isMap()) {
            return "org.apache.thrift.protocol.TType.MAP";
        } else if (trueType.isSet()) {
            return "org.apache.thrift.protocol.TType.SET";
        } else if (trueType.isList()) {
            return "org.apache.thrift.protocol.TType.LIST";
        }
        throw new RuntimeException("Unknown type for TType enum: " + trueType.getName());
    }

    private boolean isFinal(StructLikeNode struct) {
        for (TypeAnnotationNode annotation : struct.getAnnotations()) {
            if (annotation.getName().equals("final")) {
                return true;
            }
        }
        return false;
    }

    private boolean isDeprecated(Object obj) {
        if (obj instanceof StructLikeNode) {
            for (TypeAnnotationNode annotation : ((StructLikeNode) obj).getAnnotations()) {
                if (annotation.getName().equals("deprecated")) {
                    return true;
                }
            }
        } else if (obj instanceof FieldNode) {
        }
        return false;
    }

    private String makeValidJavaIdentifier(String fromName) {
        String str = fromName;
        if (str.isEmpty()) {
            return str;
        }

        char c = str.charAt(0);
        if (Character.isDigit(c)) {
            str = "_" + str;
        }

        StringBuilder result = new StringBuilder();
        for (int i = 0; i < str.length(); i++) {
            c = str.charAt(i);
            if (Character.isLetterOrDigit(c) || c == '_') {
                result.append(c);
            } else {
                result.append('_');
            }
        }
        return normalizeName(result.toString());
    }

    private String normalizeName(String name) {
        String[] keywords = {
                "abstract", "assert", "boolean", "break", "byte", "case", "catch", "char", "class", "const", "continue",
                "default", "do", "double", "else", "enum", "extends", "final", "finally", "float", "for", "goto", "if",
                "implements", "import", "instanceof", "int", "interface", "long", "native", "new", "package", "private",
                "protected", "public", "return", "short", "static", "strictfp", "super", "switch", "synchronized", "this",
                "throw", "throws", "transient", "try", "void", "volatile", "while", "true", "false", "null"
        };
        for (String keyword : keywords) {
            if (name.equals(keyword)) {
                return "$" + name;
            }
        }
        return name;
    }

    private String declareField(FieldNode field, boolean init, boolean comment) {
        StringBuilder result = new StringBuilder();
        TypeNode fieldType = field.getType();
        String originalFieldName = field.getName();
        TypeNode type = getTrueType(fieldType);

        if (typeCanBeNull(type)) {
            result.append(javaNullableAnnotation()).append(" ");
        }

        // Aligning with C++: type_name(tfield->get_type()) uses in_init=false for type declaration part
        result.append(getTypeName(type, false, false, false, false))
                .append(" ")
                .append(originalFieldName);

        if (init) {
            if (type.isBaseType()) {
                String baseName = type.getName();
                if (type.isBinary()) baseName = "binary";
                switch (baseName) {
                    case "void": break;
                    case "string": case "uuid": case "binary": result.append(" = null"); break;
                    case "bool": result.append(" = false"); break;
                    case "byte": case "i8": case "short": case "i16":
                    case "int": case "i32": case "long": case "i64":
                        result.append(" = 0"); break;
                    case "double": result.append(" = 0.0"); break;
                    default: result.append(" = /* TODO: unknown base type default */"); break;
                }
            } else if (type.isEnum()) {
                result.append(" = null");
            } else if (type.isContainer()) {
                String typeNameWithOptions = getTypeName(type, false, true, false, false);
                if (type.isMap() && getTrueType(type.getChildNodes().get(0)).isEnum() && !sortedContainers) {
                    result.append(" = new ").append(typeNameWithOptions).append("(")
                          .append(getTypeName(getTrueType(type.getChildNodes().get(0)), true, false, true, true)).append(")");
                } else if (type.isSet() && getTrueType(type.getChildNodes().get(0)).isEnum() && !sortedContainers) {
                     result.append(" = java.util.EnumSet.noneOf(")
                           .append(getTypeName(getTrueType(type.getChildNodes().get(0)), true, false, true, true)).append(")");
                } else {
                    result.append(" = new ").append(typeNameWithOptions).append("()");
                }
            } else if (type.isStruct() || type.isException()) {
                result.append(" = new ").append(getTypeName(type, false, true, false, false)).append("()");
            }
        }
        result.append(";");

        if (comment) {
            result.append(" // ");
            if (field.getRequirement() == FieldNode.Requirement.OPTIONAL) result.append("optional");
            else if (field.getRequirement() == FieldNode.Requirement.REQUIRED) result.append("required");
            else result.append("required"); // Changed 'default' to 'required' to match C++
        }
        return result.toString();
    }

    private String getTypeName(TypeNode type) {
        return getTypeName(type, false, false, false, false);
    }

    private String getTypeName(TypeNode type, boolean in_container, boolean in_init) {
        return getTypeName(type, in_container, in_init, false, false);
    }

    private String getTypeName(TypeNode type, boolean in_container, boolean in_init, boolean as_args, boolean force_namespace) {
        TypeNode trueType = getTrueType(type);
        String prefix = "";

        if (trueType.isBaseType()) {
            String baseName = trueType.getName();
            if (trueType.isBinary()) baseName = "binary";

            switch (baseName) {
                case "void": return in_container ? "Void" : "void";
                case "string": return "java.lang.String";
                case "binary": return "java.nio.ByteBuffer";
                case "uuid": return "java.util.UUID";
                case "bool": return in_container ? "java.lang.Boolean" : "boolean";
                case "byte": case "i8": return in_container ? "java.lang.Byte" : "byte";
                case "i16": return in_container ? "java.lang.Short" : "short";
                case "i32": return in_container ? "java.lang.Integer" : "int";
                case "i64": return in_container ? "java.lang.Long" : "long";
                case "double": return in_container ? "java.lang.Double" : "double";
                default: throw new RuntimeException("Unknown base type: " + baseName);
            }
        } else if (trueType.isContainer()) {
            String generics = "";
            if (!as_args) {
                if (trueType.isMap()) {
                    TypeNode keyType = trueType.getChildNodes().get(0);
                    TypeNode valueType = trueType.getChildNodes().get(1);
                    generics = "<" + getTypeName(keyType, true, false, false, true) + ","
                                   + getTypeName(valueType, true, false, false, true) + ">";
                } else if (trueType.isList() || trueType.isSet()) {
                    TypeNode elemType = trueType.getChildNodes().get(0);
                    generics = "<" + getTypeName(elemType, true, false, false, true) + ">";
                }
            }

            if (trueType.isMap()) {
                if (in_init) {
                    if (!sortedContainers && getTrueType(trueType.getChildNodes().get(0)).isEnum()) {
                        prefix = "java.util.EnumMap";
                    } else if (sortedContainers) {
                        prefix = "java.util.TreeMap";
                    } else {
                        prefix = "java.util.HashMap";
                    }
                } else {
                    prefix = "java.util.Map";
                }
            } else if (trueType.isSet()) {
                if (in_init) {
                     if (!sortedContainers && getTrueType(trueType.getChildNodes().get(0)).isEnum()) {
                        prefix = "java.util.EnumSet";
                    } else if (sortedContainers) {
                        prefix = "java.util.TreeSet";
                    } else {
                        prefix = "java.util.HashSet";
                    }
                } else {
                    prefix = "java.util.Set";
                }
            } else if (trueType.isList()) {
                prefix = in_init ? "java.util.ArrayList" : "java.util.List";
            }
            return prefix + generics;
        } else if (trueType.isStruct() || trueType.isException() || trueType.isEnum()) {
            String typeName = makeValidJavaIdentifier(trueType.getName());
            if (force_namespace) {
                if (!typeName.contains(".") && this.packageName != null && !this.packageName.isEmpty()) {
                    typeName = this.packageName + "." + typeName;
                }
            }
            if (as_args) {
                return typeName + ".class";
            }
            return typeName;
        }
        return makeValidJavaIdentifier(trueType.getName());
    }

    private TypeNode getTrueType(TypeNode type) {
        return type;
    }

    private String indent() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < indentLevel; i++) {
            sb.append("  ");
        }
        return sb.toString();
    }

    private void scope_up() {
        out.append(indent()).append("{\n");
        indentLevel++;
    }

    private void scope_down() {
        indentLevel--;
        out.append(indent()).append("}\n");
    }

    private enum IssetType {
        NONE,
        PRIMITIVE,
        BITSET
    }
}
