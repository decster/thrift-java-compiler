/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS
 * either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package com.github.decster.gen;

import com.github.decster.ast.DocumentNode;
import com.github.decster.ast.ExceptionNode;
import com.github.decster.ast.FieldNode;
import com.github.decster.ast.Node;
import com.github.decster.ast.StructLikeNode;
import com.github.decster.ast.TypeAnnotationNode;
import com.github.decster.ast.TypeNode;
import com.github.decster.ast.BaseTypeNode;
import com.github.decster.ast.MapTypeNode;

// import java.io.PrintWriter; // Not used
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/**
 * Generator for Thrift structs that produces Java code.
 * This class mirrors the functionality of the C++ implementation
 * in t_java_generator.cc
 */
public class StructLikeGenerator {

    // Configuration options
    private boolean beanStyle;
    private boolean privateMembers;
    // private boolean noCamelStyle; // Not directly used by current simplified naming
    // private boolean fullCamelStyle; // Not directly used by current simplified naming
    private boolean androidStyle;
    private boolean androidLegacy;
    private boolean sortedContainers;
    private boolean java5;
    // private boolean reuseObjects; // Not directly used yet
    private boolean useOptionType;
    private boolean useJdk8OptionType;
    private boolean undatedGeneratedAnnotations;
    private boolean suppressGeneratedAnnotations;
    // private boolean rethrowUnhandledExceptions; // Not directly used yet
    private boolean unsafeBinaries;
    // private boolean annotationsAsMetadata; // Not directly used yet
    private boolean jakartaAnnotations;

    private StructLikeNode structLikeNode;
    private DocumentNode documentNode; // Currently not used for program/namespace info due to AST limitations
    private String packageName;
    private String date;
    private StringBuilder out;

    private int indentLevel = 0;

    public StructLikeGenerator(StructLikeNode structLikeNode, DocumentNode documentNode, String packageName, String date, Map<String, Boolean> options) {
        this.structLikeNode = structLikeNode;
        this.documentNode = documentNode;
        this.packageName = packageName;
        this.date = date;
        this.out = new StringBuilder();

        this.beanStyle = options.getOrDefault("bean_style", false);
        this.privateMembers = options.getOrDefault("private_members", false);
        // this.noCamelStyle = options.getOrDefault("nocamel_style", false);
        // this.fullCamelStyle = options.getOrDefault("fullcamel_style", false);
        this.androidStyle = options.getOrDefault("android_style", false);
        this.androidLegacy = options.getOrDefault("android_legacy", false);
        this.sortedContainers = options.getOrDefault("sorted_containers", false);
        this.java5 = options.getOrDefault("java5", false);
        // this.reuseObjects = options.getOrDefault("reuse_objects", false);
        this.useOptionType = options.getOrDefault("use_option_type", false);
        this.useJdk8OptionType = options.getOrDefault("use_jdk8_option_type", false);
        this.undatedGeneratedAnnotations = options.getOrDefault("undated_generated_annotations", false);
        this.suppressGeneratedAnnotations = options.getOrDefault("suppress_generated_annotations", false);
        // this.rethrowUnhandledExceptions = options.getOrDefault("rethrow_unhandled_exceptions", false);
        this.unsafeBinaries = options.getOrDefault("unsafe_binaries", false);
        // this.annotationsAsMetadata = options.getOrDefault("annotations_as_metadata", false);
        this.jakartaAnnotations = options.getOrDefault("jakarta_annotations", false);

        if (java5) {
            this.androidLegacy = true;
        }
    }

    public String generate() {
        out.append("/**\n");
        out.append(" * Autogenerated by Thrift Compiler (0.20.0)\n");
        out.append(" *\n");
        out.append(" * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n");
        out.append(" *  @generated\n");
        out.append(" */\n");
        out.append("package ").append(packageName).append(";\n\n");
        generateStructDefinition(structLikeNode, structLikeNode instanceof ExceptionNode, false, false);
        return out.toString();
    }

    private void generateStructDefinition(StructLikeNode struct, boolean isException, boolean inClass, boolean isResult) {
        generateJavaDoc(struct);
        out.append(indent()).append(getJavaSuppressWarnings()).append("\n");

        boolean isStructFinal = isFinal(struct);
        boolean isStructDeprecated = isDeprecated(struct);

        if (!inClass && !suppressGeneratedAnnotations) {
            generateJavaxGeneratedAnnotation();
        }

        if (isStructDeprecated) {
            out.append(indent()).append("@Deprecated\n");
        }

        out.append(indent()).append("public ").append(isStructFinal ? "final " : "").append(inClass ? "static " : "")
                .append("class ").append(getEffectiveJavaIdentifier(struct.getName())).append(" ");

        if (isException) {
            out.append("extends org.apache.thrift.TException ");
        }

        String structJavaName = getEffectiveJavaIdentifier(struct.getName());
        out.append("implements org.apache.thrift.TBase<")
                .append(structJavaName).append(", ")
                .append(structJavaName)
                .append("._Fields>, java.io.Serializable, Cloneable, Comparable<")
                .append(structJavaName).append(">");

        if (androidStyle) {
            out.append(", android.os.Parcelable");
        }
        out.append(" {\n");
        indentLevel++;

        generateStructDesc(struct);
        out.append("\n");
        generateFieldDescs(struct);
        out.append("\n");
        generateSchemeMap(struct);
        out.append("\n");
        generateMemberFields(struct);
        out.append("\n");

        if (androidStyle) {
            generateJavaStructParcelable(struct);
            out.append("\n");
        }

        generateFieldNameConstants(struct);
        out.append("\n");
        generateIssetDefinitions(struct); // generateIssetDefinitions adds its own trailing newline if content is generated
        // out.append("\n"); // REMOVE THIS LINE to prevent extra blank line
        generateJavaMetaDataMap(struct);
        generateConstructors(struct);
        // generateClearMethod was called inside generateConstructors, moving it here:
        generateClearMethod(struct);
        generateGettersAndSetters(struct);
        generateSetFieldValueMethod(struct);
        generateGetFieldValueMethod(struct);
        generateIsSetFieldMethod(struct);
        generateJavaStructEquality(struct);
        generateJavaStructCompareTo(struct);
        generateJavaStructFieldById(struct);
        generateJavaStructReader(struct);
        if (isResult) {
            generateJavaStructResultWriter(struct);
        } else {
            generateJavaStructWriter(struct);
        }
        generateJavaStructToString(struct);
        generateJavaValidator(struct);
        generateJavaStructWriteObject(struct);
        generateJavaStructReadObject(struct);
        generateJavaStructStandardScheme(struct, isResult);
        generateJavaStructTupleScheme(struct);
        generateJavaSchemeLookup();

        indentLevel--;
        out.append(indent()).append("}\n");
    }


    private String getEffectiveJavaIdentifier(String originalName) {
        return makeValidJavaIdentifier(originalName);
    }


    private void generateStructDesc(StructLikeNode struct) {
        out.append(indent()).append("private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new ")
                .append("org.apache.thrift.protocol.TStruct(\"")
                .append(struct.getName()).append("\");\n");
    }

    private void generateFieldDescs(StructLikeNode struct) {
        for (FieldNode field : struct.getFields()) {
            String originalFieldName = field.getName(); // Use original name
            TypeNode fieldType = field.getType();       // Use original type

            out.append(indent()).append("private static final org.apache.thrift.protocol.TField ")
                    .append(constantName(originalFieldName).toUpperCase())
                    .append("_FIELD_DESC = new org.apache.thrift.protocol.TField(\"")
                    .append(originalFieldName)
                    .append("\", ").append(typeToEnum(fieldType)) // typeToEnum will now handle MapTypeNode for "yy"
                    .append(", (short)").append(field.getId()).append(");\n");
        }
    }

    private void generateSchemeMap(StructLikeNode struct) {
        out.append(indent()).append("private static final org.apache.thrift.scheme.SchemeFactory ")
                .append("STANDARD_SCHEME_FACTORY = new ")
                .append(getEffectiveJavaIdentifier(struct.getName())).append("StandardSchemeFactory();\n");

        out.append(indent()).append("private static final org.apache.thrift.scheme.SchemeFactory ")
                .append("TUPLE_SCHEME_FACTORY = new ")
                .append(getEffectiveJavaIdentifier(struct.getName())).append("TupleSchemeFactory();\n");
    }

    private void generateMemberFields(StructLikeNode struct) {
        for (FieldNode field : struct.getFields()) {
            if (beanStyle || privateMembers) {
                out.append(indent()).append("private ");
            } else {
                generateJavaDoc(field);
                out.append(indent()).append("public ");
            }
            out.append(declareField(field, false, true)).append("\n");
        }
    }

    private void generateFieldNameConstants(StructLikeNode struct) {
        out.append(indent()).append("/** The set of fields this struct contains, along with convenience methods for ")
                .append("finding and manipulating them. */\n");

        out.append(indent()).append("public enum _Fields implements org.apache.thrift.TFieldIdEnum {\n");
        indentLevel++;

        boolean first = true;
        for (FieldNode field : struct.getFields()) {
            if (!first) {
                out.append(",\n");
            }
            first = false;

            generateJavaDoc(field);
            String originalFieldName = field.getName(); // Use original name
            out.append(indent()).append(constantName(originalFieldName).toUpperCase())
                    .append("((short)").append(field.getId())
                    .append(", \"").append(originalFieldName).append("\")");
        }

        out.append(";\n\n");

        out.append(indent()).append("private static final java.util.Map<java.lang.String, _Fields> byName = new ")
                .append("java.util.HashMap<java.lang.String, _Fields>();\n\n");

        out.append(indent()).append("static {\n");
        indentLevel++;
        out.append(indent()).append("for (_Fields field : java.util.EnumSet.allOf(_Fields.class)) {\n");
        indentLevel++;
        out.append(indent()).append("byName.put(field.getFieldName(), field);\n");
        indentLevel--;
        out.append(indent()).append("}\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");

        out.append(indent()).append("/**\n");
        out.append(indent()).append(" * Find the _Fields constant that matches fieldId, or null if its not found.\n");
        out.append(indent()).append(" */\n");
        out.append(indent()).append(javaNullableAnnotation()).append("\n");
        out.append(indent()).append("public static _Fields findByThriftId(int fieldId) {\n");
        indentLevel++;
        out.append(indent()).append("switch(fieldId) {\n");
        indentLevel++;
        for (FieldNode field : struct.getFields()) {
            String originalFieldName = field.getName(); // Use original name
            out.append(indent()).append("case ").append(field.getId()).append(": // ")
                    .append(constantName(originalFieldName).toUpperCase()).append("\n");
            out.append(indent()).append("  return ").append(constantName(originalFieldName).toUpperCase()).append(";\n");
        }
        out.append(indent()).append("default:\n");
        out.append(indent()).append("  return null;\n");
        indentLevel--;
        out.append(indent()).append("}\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");

        out.append(indent()).append("/**\n");
        out.append(indent()).append(" * Find the _Fields constant that matches fieldId, throwing an exception\n");
        out.append(indent()).append(" * if it is not found.\n");
        out.append(indent()).append(" */\n");
        out.append(indent()).append("public static _Fields findByThriftIdOrThrow(int fieldId) {\n");
        indentLevel++;
        out.append(indent()).append("_Fields fields = findByThriftId(fieldId);\n");
        out.append(indent()).append("if (fields == null) throw new java.lang.IllegalArgumentException(\"Field \" + ")
                .append("fieldId + \" doesn't exist!\");\n");
        out.append(indent()).append("return fields;\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");

        out.append(indent()).append("/**\n");
        out.append(indent()).append(" * Find the _Fields constant that matches name, or null if its not found.\n");
        out.append(indent()).append(" */\n");
        out.append(indent()).append(javaNullableAnnotation()).append("\n");
        out.append(indent()).append("public static _Fields findByName(java.lang.String name) {\n");
        indentLevel++;
        out.append(indent()).append("return byName.get(name);\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");

        out.append(indent()).append("private final short _thriftId;\n");
        out.append(indent()).append("private final java.lang.String _fieldName;\n\n");

        out.append(indent()).append("_Fields(short thriftId, java.lang.String fieldName) {\n");
        indentLevel++;
        out.append(indent()).append("_thriftId = thriftId;\n");
        out.append(indent()).append("_fieldName = fieldName;\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");

        out.append(indent()).append(javaOverrideAnnotation()).append("\n");
        out.append(indent()).append("public short getThriftFieldId() {\n");
        indentLevel++;
        out.append(indent()).append("return _thriftId;\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");

        out.append(indent()).append(javaOverrideAnnotation()).append("\n");
        out.append(indent()).append("public java.lang.String getFieldName() {\n");
        indentLevel++;
        out.append(indent()).append("return _fieldName;\n");
        indentLevel--;
        out.append(indent()).append("}\n");
        indentLevel--;
        out.append(indent()).append("}\n");
    }

    private void generateIssetDefinitions(StructLikeNode struct) {
        List<FieldNode> fields = struct.getFields();
        if (!fields.isEmpty()) {
            out.append(indent()).append("// isset id assignments\n"); // ADDED COMMENT
            out.append(indent());

            int count = 0;
            int optionals = 0;
            List<String> issetIds = new ArrayList<>();

            for (FieldNode field : fields) {
                String originalFieldName = field.getName(); // Use original name
                TypeNode fieldType = field.getType();       // Use original type

                if (field.getRequirement() == FieldNode.Requirement.OPTIONAL) {
                    optionals++;
                }
                if (!typeCanBeNull(fieldType)) { // typeCanBeNull will now correctly assess MapTypeNode for "yy"
                    String issetIdConstant = "__" + constantName(originalFieldName).toUpperCase() + "_ISSET_ID";
                    issetIds.add(issetIdConstant);
                    out.append("private static final int ").append(issetIdConstant)
                            .append(" = ").append(count).append(";\n").append(indent());
                    count++;
                }
            }
            if (count == 0 && optionals == 0 && fields.stream().allMatch(f -> typeCanBeNull(f.getType()))) {
            } else if (count > 0) {
                IssetType issetType = needsIsset(struct);
                String primitiveType = determinePrimitiveType(count);

                switch (issetType) {
                    case PRIMITIVE:
                        out.append("private ").append(primitiveType)
                                .append(" __isset_bitfield = 0;\n").append(indent());
                        break;
                    case BITSET:
                        out.append("private java.util.BitSet __isset_bit_vector = new java.util.BitSet(")
                                .append(count).append(");\n").append(indent());
                        break;
                    case NONE:
                        break;
                }
            }

            if (optionals > 0) {
                StringBuilder output = new StringBuilder("private static final _Fields optionals[] = {");
                boolean firstOptional = true;
                for (FieldNode field : fields) {
                    String originalFieldName = field.getName(); // Use original name
                    if (field.getRequirement() == FieldNode.Requirement.OPTIONAL) {
                        if (!firstOptional) output.append(", ");
                        output.append("_Fields.").append(constantName(originalFieldName).toUpperCase());
                        firstOptional = false;
                    }
                }
                output.append("};");
                out.append(output.toString()).append("\n");
            } else {
                if (count > 0) out.append("\n");
            }
        }
    }

    private void generateJavaMetaDataMap(StructLikeNode struct) {
        out.append(indent()).append("public static final java.util.Map<_Fields, ")
                .append("org.apache.thrift.meta_data.FieldMetaData> metaDataMap;\n");
        out.append(indent()).append("static {\n");
        indentLevel++;

        out.append(indent())
                .append("java.util.Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new ")
                .append("java.util.EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);\n");

        for (FieldNode field : struct.getFields()) {
            String originalFieldName = field.getName(); // Use original name
            TypeNode fieldType = field.getType();       // Use original type

            out.append(indent()).append("tmpMap.put(_Fields.").append(constantName(originalFieldName).toUpperCase())
                    .append(", new org.apache.thrift.meta_data.FieldMetaData(\"").append(originalFieldName).append("\", ");

            FieldNode.Requirement req = field.getRequirement();
            if (req == FieldNode.Requirement.REQUIRED) {
                out.append("org.apache.thrift.TFieldRequirementType.REQUIRED, "); // Comma and space
            } else if (req == FieldNode.Requirement.OPTIONAL) {
                out.append("org.apache.thrift.TFieldRequirementType.OPTIONAL, "); // Comma and space
            } else {
                out.append("org.apache.thrift.TFieldRequirementType.DEFAULT, "); // Comma and space
            }
            out.append("\n").append(indent()).append("    "); // Newline, then indent and 4 alignment spaces
            out.append(generateFieldValueMetaData(fieldType)).append("));\n"); // generateFieldValueMetaData then closing parens
        }

        out.append(indent()).append("metaDataMap = java.util.Collections.unmodifiableMap(tmpMap);\n");
        out.append(indent()).append("org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(")
                .append(getEffectiveJavaIdentifier(struct.getName())).append(".class, metaDataMap);\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");
    }

    private String generateFieldValueMetaData(TypeNode type) {
        TypeNode trueType = getTrueType(type);
        StringBuilder sb = new StringBuilder();

        // Remove the "yy" hack for FieldValueMetaData type determination
        // if (type instanceof BaseTypeNode && type.getName().equals("double") &&
        //     structLikeNode != null && structLikeNode.getFields().stream().anyMatch(f -> f.getName().equals("yy") && f.getType() instanceof MapTypeNode) ) {
        //      trueType = new BaseTypeNode(BaseTypeNode.BaseTypeEnum.DOUBLE);
        // }


        if (trueType.isStruct() || trueType.isException()) {
            sb.append("new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, ")
                    .append(getTypeName(trueType, false, false, true, true)).append(")");
        } else if (trueType.isContainer()) {
            if (trueType.isList()) {
                TypeNode elemType = trueType.getChildNodes().get(0);
                sb.append("new org.apache.thrift.meta_data.ListMetaData(org.apache.thrift.protocol.TType.LIST, ")
                        .append(generateFieldValueMetaData(elemType)).append(")");
            } else if (trueType.isSet()) {
                TypeNode elemType = trueType.getChildNodes().get(0);
                sb.append("new org.apache.thrift.meta_data.SetMetaData(org.apache.thrift.protocol.TType.SET, ")
                        .append(generateFieldValueMetaData(elemType)).append(")");
            } else { // Map
                TypeNode keyType = trueType.getChildNodes().get(0);
                TypeNode valType = trueType.getChildNodes().get(1);
                sb.append("new org.apache.thrift.meta_data.MapMetaData(org.apache.thrift.protocol.TType.MAP, ")
                        .append(generateFieldValueMetaData(keyType)).append(", ")
                        .append(generateFieldValueMetaData(valType)).append(")");
            }
        } else if (trueType.isEnum()) {
            sb.append("new org.apache.thrift.meta_data.EnumMetaData(org.apache.thrift.protocol.TType.ENUM, ")
                    .append(getTypeName(trueType, false, false, true, true)).append(")");
        } else {
            sb.append("new org.apache.thrift.meta_data.FieldValueMetaData(").append(typeToEnum(trueType));
            if (trueType.isBinary() && ! (trueType instanceof BaseTypeNode && trueType.getName().equals("double") ) ) {
                sb.append(", true");
            }
            if (type.isTypedef() && !type.getName().equals(trueType.getName())) {
                sb.append(", \"").append(type.getName()).append("\"");
            }
            sb.append(")");
        }
        return sb.toString();
    }

    private void generateConstructors(StructLikeNode struct) {
        generateDefaultConstructor(struct);
        generateFullConstructor(struct);
        generateCopyConstructor(struct);
        generateDeepCopyMethod(struct);
        // generateClearMethod(struct); // REMOVE call from here
    }

    private void generateClearMethod(StructLikeNode struct) {
        out.append(indent()).append(javaOverrideAnnotation()).append("\n");
        out.append(indent()).append("public void clear() {\n");
        indentLevel++;
        for (FieldNode field : struct.getFields()) {
            String originalFieldName = field.getName(); // Use original name
            String capName = capitalizedName(originalFieldName); // Pass original name
            TypeNode fieldType = field.getType(); // Use original type

            if (typeCanBeNull(fieldType)) {
                out.append(indent()).append("this.").append(originalFieldName).append(" = null;\n");
            } else {
                // For primitives, unset the isset flag and set to default value
                out.append(indent()).append("set").append(capName).append("IsSet(false);\n");
                // Determine default value based on type
                String baseName = fieldType.getName();
                if (fieldType.isBinary()) baseName = "binary";

                switch (baseName) {
                    case "bool":
                        out.append(indent()).append("this.").append(originalFieldName).append(" = false;\n");
                        break;
                    case "byte": case "i8":
                    case "short": case "i16":
                    case "int": case "i32":
                    case "long": case "i64":
                        out.append(indent()).append("this.").append(originalFieldName).append(" = 0;\n");
                        break;
                    case "double":
                        out.append(indent()).append("this.").append(originalFieldName).append(" = 0.0;\n");
                        break;
                    // String, binary, uuid cases are handled by typeCanBeNull branch
                }
            }
        }
        indentLevel--;
        out.append(indent()).append("}\n\n");
    }

    private void generateDefaultConstructor(StructLikeNode struct) {
        out.append(indent()).append("public ").append(getEffectiveJavaIdentifier(struct.getName())).append("() {\n");
        indentLevel++;
        for (FieldNode field : struct.getFields()) {
            if (field.getDefaultValue() != null) {
                out.append(indent()).append("this.").append(field.getName()) // Use original name
                        .append(" = ").append("/* TODO: renderConstValue for default */ ")
                        .append(field.getDefaultValue().toString()).append(";\n");
            }
        }
        indentLevel--;
        out.append(indent()).append("}\n\n");
    }

    private void generateFullConstructor(StructLikeNode struct) {
        List<FieldNode> fullConstructorFields = new ArrayList<>();
        boolean allOptional = true;
        for (FieldNode field : struct.getFields()) {
            if (field.getRequirement() != FieldNode.Requirement.OPTIONAL) {
                fullConstructorFields.add(field);
                allOptional = false;
            }
        }

        if (!struct.getFields().isEmpty() && !allOptional) {
            out.append(indent()).append("public ").append(getEffectiveJavaIdentifier(struct.getName())).append("(\n");
            indentLevel++;
            for (int i = 0; i < fullConstructorFields.size(); i++) {
                FieldNode field = fullConstructorFields.get(i);
                TypeNode fieldType = field.getType(); // Use original type
                out.append(indent()).append(getTypeName(fieldType))
                        .append(" ").append(field.getName()); // Use original name
                if (i < fullConstructorFields.size() - 1) {
                    out.append(",\n");
                }
            }
            out.append(")\n"); // Parameters end, newline
            indentLevel--; // Decrease indent level for the opening brace line
            out.append(indent()).append("{\n"); // Opening brace on new line, at correct indent
            indentLevel++; // Increase indent for the body of the constructor

            out.append(indent()).append("this();\n");
            for (FieldNode field : fullConstructorFields) {
                String originalFieldName = field.getName(); // Use original name
                TypeNode fieldType = field.getType(); // Use original type

                if (fieldType.isBinary() && !unsafeBinaries) {
                    out.append(indent()).append("this.").append(originalFieldName)
                            .append(" = org.apache.thrift.TBaseHelper.copyBinary(").append(originalFieldName).append(");\n");
                } else {
                    out.append(indent()).append("this.").append(originalFieldName).append(" = ").append(originalFieldName).append(";\n");
                }
                if (!typeCanBeNull(fieldType)) {
                    out.append(indent()).append("set").append(capitalizedName(originalFieldName)).append("IsSet(true);\n");
                }
            }
            indentLevel--; // Decrease indent for the closing brace
            out.append(indent()).append("}\n\n");
        }
    }

    private void generateCopyConstructor(StructLikeNode struct) {
        String structJavaName = getEffectiveJavaIdentifier(struct.getName());
        out.append(indent()).append("/**\n");
        out.append(indent()).append(" * Performs a deep copy on <i>other</i>.\n");
        out.append(indent()).append(" */\n");
        out.append(indent()).append("public ").append(structJavaName).append("(").append(structJavaName).append(" other) {\n");
        indentLevel++;

        IssetType issetType = needsIsset(struct); // needsIsset is now de-hacked
        switch (issetType) {
            case PRIMITIVE:
                out.append(indent()).append("__isset_bitfield = other.__isset_bitfield;\n");
                break;
            case BITSET:
                // Check if any field that *requires* isset tracking (primitives) exists
                boolean needsIssetVectorCopy = false;
                for(FieldNode fNode : struct.getFields()){
                    if(!typeCanBeNull(fNode.getType())){ // Use original type
                        needsIssetVectorCopy = true;
                        break;
                    }
                }
                if (needsIssetVectorCopy) {
                    out.append(indent()).append("__isset_bit_vector = new java.util.BitSet(other.__isset_bit_vector.length());\n");
                    out.append(indent()).append("__isset_bit_vector.or(other.__isset_bit_vector);\n");
                }
                break;
            case NONE:
                break;
        }

        for (FieldNode field : struct.getFields()) {
            String originalFieldName = field.getName(); // Use original name
            TypeNode fieldType = field.getType();       // Use original type

            if (typeCanBeNull(fieldType)) {
                out.append(indent()).append("if (other.isSet").append(capitalizedName(originalFieldName)).append("()) {\n");
                indentLevel++;
            }

            String sourceFieldAccess = "other." + originalFieldName;
            if (fieldType.isContainer()) {
                String copiedContainerName = "this." + originalFieldName;
                generateDeepCopyContainer(fieldType, sourceFieldAccess, copiedContainerName);
            } else {
                out.append(indent()).append("this.").append(originalFieldName).append(" = ");
                generateDeepCopyNonContainer(fieldType, sourceFieldAccess, "this." + originalFieldName);
                out.append(";\n");
            }

            if (typeCanBeNull(fieldType)) {
                indentLevel--;
                out.append(indent()).append("}\n");
            }
        }
        indentLevel--;
        out.append(indent()).append("}\n\n");
    }

    private void generateDeepCopyMethod(StructLikeNode struct) {
        String structName = getEffectiveJavaIdentifier(struct.getName());
        out.append(indent()).append(javaOverrideAnnotation()).append("\n");
        out.append(indent()).append("public ").append(structName).append(" deepCopy() {\n");
        indentLevel++;
        out.append(indent()).append("return new ").append(structName).append("(this);\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");
    }

    private void generateDeepCopyContainer(TypeNode type, String sourceName, String destName) {
        TypeNode trueType = getTrueType(type);
        String containerTypeName = getTypeName(trueType, false, true, false, false);
        String elementTypeName;

        if (trueType.isList()) {
            TypeNode elemType = getTrueType(trueType.getChildNodes().get(0));
            elementTypeName = getTypeName(elemType, true, false, false, true);
            out.append(indent()).append(destName).append(" = new ").append(containerTypeName).append("();\n");
            out.append(indent()).append("for (").append(elementTypeName).append(" __item : ").append(sourceName).append(") {\n");
            indentLevel++;
            if (elemType.isContainer()) {
                String tempItemCopy = "__item_copy_" + System.nanoTime();
                out.append(indent()).append(getTypeName(elemType, false, true, false, true) + " " + tempItemCopy + ";\n");
                generateDeepCopyContainer(elemType, "__item", tempItemCopy);
                out.append(indent()).append(destName).append(".add(").append(tempItemCopy).append(");\n");
            } else {
                out.append(indent());
                String tempCopy = "";
                boolean isComplexCopy = elemType.isBinary() || elemType.isStruct() || elemType.isException();
                if(isComplexCopy) {
                    tempCopy = "__item_copy_val_" + System.nanoTime();
                    out.append(getTypeName(elemType, false, false, false, true)).append(" ").append(tempCopy).append(" = ");
                }
                generateDeepCopyNonContainer(elemType, "__item", tempCopy);
                if(isComplexCopy) {
                    out.append(";\n");
                    out.append(indent()).append(destName).append(".add(").append(tempCopy).append(");\n");
                } else {
                    out.append(";\n").append(indent()).append(destName).append(".add(__item);\n");
                }
            }
            indentLevel--;
            out.append(indent()).append("}\n");
        } else if (trueType.isSet()) {
            TypeNode elemType = getTrueType(trueType.getChildNodes().get(0));
            elementTypeName = getTypeName(elemType, true, false, false, true);
            if (elemType.isEnum() && !sortedContainers) {
                out.append(indent()).append(destName).append(" = java.util.EnumSet.copyOf(").append(sourceName).append(");\n");
            } else {
                out.append(indent()).append(destName).append(" = new ").append(containerTypeName).append("();\n");
                out.append(indent()).append("for (").append(elementTypeName).append(" __item : ").append(sourceName).append(") {\n");
                indentLevel++;
                if (elemType.isContainer()) {
                    String tempItemCopy = "__item_copy_" + System.nanoTime();
                    out.append(indent()).append(getTypeName(elemType, false, true, false, true) + " " + tempItemCopy + ";\n");
                    generateDeepCopyContainer(elemType, "__item", tempItemCopy);
                    out.append(indent()).append(destName).append(".add(").append(tempItemCopy).append(");\n");
                } else {
                    out.append(indent());
                    String tempCopy = "";
                    boolean isComplexCopy = elemType.isBinary() || elemType.isStruct() || elemType.isException();
                    if(isComplexCopy) {
                        tempCopy = "__item_copy_val_" + System.nanoTime();
                        out.append(getTypeName(elemType, false, false, false, true)).append(" ").append(tempCopy).append(" = ");
                    }
                    generateDeepCopyNonContainer(elemType, "__item", tempCopy);
                    if(isComplexCopy) {
                        out.append(";\n");
                        out.append(indent()).append(destName).append(".add(").append(tempCopy).append(");\n");
                    } else {
                        out.append(";\n").append(indent()).append(destName).append(".add(__item);\n");
                    }
                }
                indentLevel--;
                out.append(indent()).append("}\n");
            }
        } else if (trueType.isMap()) {
            TypeNode keyType = getTrueType(trueType.getChildNodes().get(0));
            TypeNode valueType = getTrueType(trueType.getChildNodes().get(1));
            String keyTypeName = getTypeName(keyType, true, false, false, true);
            String valueTypeName = getTypeName(valueType, true, false, false, true);

            if (keyType.isEnum() && !sortedContainers) {
                out.append(indent()).append(destName).append(" = new java.util.EnumMap<>(").append(getTypeName(keyType, false, false, true, true)).append(");\n");
                out.append(indent()).append("for (java.util.Map.Entry<").append(keyTypeName).append(", ").append(valueTypeName).append("> __entry : (java.util.Set<java.util.Map.Entry<").append(keyTypeName).append(", ").append(valueTypeName).append(">>)").append(sourceName).append(".entrySet()) {\n");
                indentLevel++;
                String tempKeyCopy = "__entry.getKey()";
                String tempValueCopy = "__value_copy_" + System.nanoTime();
                out.append(indent()).append(getTypeName(valueType, false, true, false, true) + " " + tempValueCopy + ";\n");
                if (valueType.isContainer()){
                    generateDeepCopyContainer(valueType, "__entry.getValue()", tempValueCopy);
                } else {
                    generateDeepCopyNonContainer(valueType, "__entry.getValue()", tempValueCopy);
                }
                out.append(indent()).append(destName).append(".put(").append(tempKeyCopy).append(", ").append(tempValueCopy).append(");\n");
                indentLevel--;
                out.append(indent()).append("}\n");

            } else {
                out.append(indent()).append(destName).append(" = new ").append(containerTypeName).append("();\n");
                out.append(indent()).append("for (java.util.Map.Entry<").append(keyTypeName).append(", ").append(valueTypeName).append("> __entry : ").append(sourceName).append(".entrySet()) {\n");
                indentLevel++;
                String tempKeyCopyVar = "__key_copy_" + System.nanoTime();
                String tempValueCopyVar = "__value_copy_" + System.nanoTime();

                out.append(indent()).append(getTypeName(keyType, false, false, false, true) + " " + tempKeyCopyVar + ";\n");
                if (keyType.isContainer()) {
                    generateDeepCopyContainer(keyType, "__entry.getKey()", tempKeyCopyVar);
                } else {
                    out.append(indent()).append(tempKeyCopyVar).append(" = ");
                    generateDeepCopyNonContainer(keyType, "__entry.getKey()", tempKeyCopyVar);
                    out.append(";\n");
                }

                out.append(indent()).append(getTypeName(valueType, false, false, false, true) + " " + tempValueCopyVar + ";\n");
                if (valueType.isContainer()){
                    generateDeepCopyContainer(valueType, "__entry.getValue()", tempValueCopyVar);
                } else {
                    out.append(indent()).append(tempValueCopyVar).append(" = ");
                    generateDeepCopyNonContainer(valueType, "__entry.getValue()", tempValueCopyVar);
                    out.append(";\n");
                }
                out.append(indent()).append(destName).append(".put(").append(tempKeyCopyVar).append(", ").append(tempValueCopyVar).append(");\n");
                indentLevel--;
                out.append(indent()).append("}\n");
            }
        } else {
            out.append(indent()).append("// TODO: Deep copy for unknown container type: ").append(trueType.getName()).append("\n");
            out.append(indent()).append(destName).append(" = ").append(sourceName).append("; // Fallback to shallow copy\n");
        }
    }

    private void generateDeepCopyNonContainer(TypeNode type, String sourceName, String destNameForNew) {
        TypeNode trueType = getTrueType(type);
        if (trueType.isBaseType() || trueType.isEnum()) {
            if (trueType.isBinary() && !unsafeBinaries) {
                out.append("org.apache.thrift.TBaseHelper.copyBinary(").append(sourceName).append(")");
            } else {
                out.append(sourceName);
            }
        } else if (trueType.isStruct() || trueType.isException()) {
            out.append("new ").append(getTypeName(trueType, false, false, false, true))
                    .append("(").append(sourceName).append(")");
        } else {
            out.append(sourceName);
        }
    }

    private String capitalizedName(String name) {
        if (name == null || name.isEmpty()) {
            return name;
        }
        // String effectiveName = getEffectiveFieldName(name); // Removed: use name directly
        return name.substring(0, 1).toUpperCase() + name.substring(1);
    }

    private void generateGettersAndSetters(StructLikeNode struct) {
        for (FieldNode field : struct.getFields()) {
            TypeNode fieldType = field.getType(); // Use original type
            String originalFieldName = field.getName(); // Use original name

            TypeNode trueType = getTrueType(fieldType); // trueType based on original fieldType
            String capName = capitalizedName(originalFieldName); // Pass original name
            boolean isOptional = field.getRequirement() == FieldNode.Requirement.OPTIONAL;

            if (trueType.isContainer()) {
                generateContainerMethods(field, trueType, originalFieldName, capName, isOptional);
            }
            generateGetter(field, trueType, originalFieldName, capName, isOptional);
            generateSetter(field, trueType, originalFieldName, capName);
            generateUnsetter(field, trueType, originalFieldName, capName);
            generateIsSetMethod(field, trueType, originalFieldName, capName);
            generateSetIsSetMethod(field, trueType, originalFieldName, capName);
        }
    }

    private void generateContainerMethods(FieldNode field, TypeNode trueType, String fieldName, String capName, boolean isOptional) {
        if (useOptionType && isOptional) {
            String optionClassName = useJdk8OptionType ? "java.util.Optional" : "org.apache.thrift.Option";
            out.append(indent()).append("public ").append(optionClassName).append("<Integer> get").append(capName).append("Size() {\n");
            indentLevel++;
            out.append(indent()).append("if (this.").append(fieldName).append(" == null) {\n");
            indentLevel++;
            out.append(indent()).append("return ").append(optionClassName).append(".empty();\n");
            indentLevel--;
            out.append(indent()).append("} else {\n");
            indentLevel++;
            out.append(indent()).append("return ").append(optionClassName).append(".of(this.").append(fieldName).append(".size());\n");
            indentLevel--;
            out.append(indent()).append("}\n");
            indentLevel--;
            out.append(indent()).append("}\n\n");
        } else {
            out.append(indent()).append("public int get").append(capName).append("Size() {\n");
            indentLevel++;
            out.append(indent()).append("return (this.").append(fieldName).append(" == null) ? 0 : this.").append(fieldName).append(".size();\n");
            indentLevel--;
            out.append(indent()).append("}\n\n");
        }

        if (trueType.isList() || trueType.isSet()) {
            TypeNode elemType = getTrueType(trueType.getChildNodes().get(0));
            String elemTypeName = getTypeName(elemType, true, false, false, true);
            if (useOptionType && isOptional) {
                String optionClassName = useJdk8OptionType ? "java.util.Optional" : "org.apache.thrift.Option";
                out.append(indent()).append("public ").append(optionClassName).append("<java.util.Iterator<").append(elemTypeName).append(">> get")
                        .append(capName).append("Iterator() {\n");
                indentLevel++;
                out.append(indent()).append("if (this.").append(fieldName).append(" == null) {\n");
                indentLevel++;
                out.append(indent()).append("return ").append(optionClassName).append(".empty();\n");
                indentLevel--;
                out.append(indent()).append("} else {\n");
                indentLevel++;
                out.append(indent()).append("return ").append(optionClassName).append(".of(this.").append(fieldName).append(".iterator());\n");
                indentLevel--;
                out.append(indent()).append("}\n");
                indentLevel--;
                out.append(indent()).append("}\n\n");
            } else {
                out.append(indent()).append(javaNullableAnnotation()).append("\n");
                out.append(indent()).append("public java.util.Iterator<").append(elemTypeName).append("> get").append(capName).append("Iterator() {\n");
                indentLevel++;
                out.append(indent()).append("return (this.").append(fieldName).append(" == null) ? null : this.").append(fieldName).append(".iterator();\n");
                indentLevel--;
                out.append(indent()).append("}\n\n");
            }

            out.append(indent()).append("public void addTo").append(capName).append("(").append(getTypeName(elemType)).append(" elem) {\n");
            indentLevel++;
            out.append(indent()).append("if (this.").append(fieldName).append(" == null) {\n");
            indentLevel++;
            String containerInitType = getTypeName(trueType, false, true, false, false);
            if (elemType.isEnum() && !sortedContainers && trueType.isSet()) {
                out.append(indent()).append("this.").append(fieldName).append(" = java.util.EnumSet.noneOf(")
                        .append(getTypeName(elemType, true, false, true, true)).append(");\n");
            } else {
                out.append(indent()).append("this.").append(fieldName).append(" = new ").append(containerInitType).append("();\n");
            }
            indentLevel--;
            out.append(indent()).append("}\n");
            out.append(indent()).append("this.").append(fieldName).append(".add(elem);\n");
            indentLevel--;
            out.append(indent()).append("}\n\n");

        } else if (trueType.isMap()) {
            TypeNode keyType = getTrueType(trueType.getChildNodes().get(0));
            TypeNode valueType = getTrueType(trueType.getChildNodes().get(1));
            out.append(indent()).append("public void putTo").append(capName).append("(")
                    .append(getTypeName(keyType)).append(" key, ")
                    .append(getTypeName(valueType)).append(" val) {\n");
            indentLevel++;
            out.append(indent()).append("if (this.").append(fieldName).append(" == null) {\n");
            indentLevel++;
            String mapInitType = getTypeName(trueType, false, true, false, false);
            if (keyType.isEnum() && !sortedContainers) {
                out.append(indent()).append("this.").append(fieldName).append(" = new ").append(mapInitType).append("(")
                        .append(getTypeName(keyType, true, false, true, true)).append(");\n");
            } else {
                out.append(indent()).append("this.").append(fieldName).append(" = new ").append(mapInitType).append("();\n");
            }
            indentLevel--;
            out.append(indent()).append("}\n");
            out.append(indent()).append("this.").append(fieldName).append(".put(key, val);\n");
            indentLevel--;
            out.append(indent()).append("}\n\n");
        }
    }

    private void generateGetter(FieldNode field, TypeNode trueType, String fieldName, String capName, boolean isOptional) {
        generateJavaDoc(field);
        if (trueType.isBinary()) {
            out.append(indent()).append("public byte[] get").append(capName).append("() {\n");
            indentLevel++;
            out.append(indent()).append("java.nio.ByteBuffer bf = bufferFor").append(capName).append("();\n");
            out.append(indent()).append("return (bf == null ? null : bf.array());\n");
            indentLevel--;
            out.append(indent()).append("}\n\n");

            out.append(indent()).append(javaNullableAnnotation()).append("\n");
            out.append(indent()).append("public java.nio.ByteBuffer bufferFor").append(capName).append("() {\n");
            indentLevel++;
            if (unsafeBinaries) {
                out.append(indent()).append("return this.").append(fieldName).append(";\n");
            } else {
                out.append(indent()).append("return org.apache.thrift.TBaseHelper.copyBinary(this.").append(fieldName).append(");\n");
            }
            indentLevel--;
            out.append(indent()).append("}\n\n");
        } else {
            String getterName;
            if (trueType.isBaseType() && "bool".equals(trueType.getName())) {
                getterName = "is" + capName;
            } else {
                getterName = "get" + capName;
            }

            if (useOptionType && isOptional) {
                String optionClassName = useJdk8OptionType ? "java.util.Optional" : "org.apache.thrift.Option";
                out.append(indent()).append("public ").append(optionClassName).append("<").append(getTypeName(trueType, true, false, false, false)).append("> ")
                        .append(getterName).append("() {\n");
                indentLevel++;
                out.append(indent()).append("if (this.isSet").append(capName).append("()) {\n");
                indentLevel++;
                out.append(indent()).append("return ").append(optionClassName).append(".of(this.").append(fieldName).append(");\n");
                indentLevel--;
                out.append(indent()).append("} else {\n");
                indentLevel++;
                out.append(indent()).append("return ").append(optionClassName).append(".empty();\n");
                indentLevel--;
                out.append(indent()).append("}\n");
                indentLevel--;
                out.append(indent()).append("}\n\n");
            } else {
                if (typeCanBeNull(trueType)) {
                    out.append(indent()).append(javaNullableAnnotation()).append("\n");
                }
                out.append(indent()).append("public ").append(getTypeName(trueType)).append(" ")
                        .append(getterName).append("() {\n");
                indentLevel++;
                out.append(indent()).append("return this.").append(fieldName).append(";\n");
                indentLevel--;
                out.append(indent()).append("}\n\n");
            }
        }
    }

    private void generateSetter(FieldNode field, TypeNode trueType, String fieldName, String capName) {
        generateJavaDoc(field);
        String returnType = beanStyle ? "void" : getEffectiveJavaIdentifier(structLikeNode.getName());
        String params;

        if (trueType.isBinary()) {
            params = (typeCanBeNull(trueType) ? javaNullableAnnotation() + " " : "") +
                    "java.nio.ByteBuffer" + " " + fieldName;

            out.append(indent()).append("public ").append(returnType).append(" set").append(capName).append("(").append(params).append(") {\n");
            indentLevel++;
            if (unsafeBinaries) {
                out.append(indent()).append("this.").append(fieldName).append(" = ").append(fieldName).append(";\n");
            } else {
                out.append(indent()).append("this.").append(fieldName).append(" = org.apache.thrift.TBaseHelper.copyBinary(").append(fieldName).append(");\n");
            }
            if (!beanStyle) {
                out.append(indent()).append("return this;\n");
            }
            indentLevel--;
            out.append(indent()).append("}\n\n");

            generateJavaDoc(field);
            params = (typeCanBeNull(trueType) ? javaNullableAnnotation() + " " : "") +
                    "byte[]" + " " + fieldName;

            out.append(indent()).append("public ").append(returnType).append(" set").append(capName).append("(").append(params).append(") {\n");
            indentLevel++;
            out.append(indent()).append("set").append(capName).append("(").append(fieldName)
                    .append(" == null ? (java.nio.ByteBuffer)null");
            if (unsafeBinaries) {
                out.append(" : java.nio.ByteBuffer.wrap(").append(fieldName).append("));\n");
            } else {
                out.append(" : java.nio.ByteBuffer.wrap(").append(fieldName).append(".clone()));\n");
            }
            if (!beanStyle) {
                out.append(indent()).append("return this;\n");
            }
            indentLevel--;
            out.append(indent()).append("}\n\n");

        } else {
            params = (typeCanBeNull(trueType) ? javaNullableAnnotation() + " " : "") +
                    getTypeName(trueType) + " " + fieldName;
            out.append(indent()).append("public ").append(returnType).append(" set").append(capName).append("(").append(params).append(") {\n");
            indentLevel++;
            out.append(indent()).append("this.").append(fieldName).append(" = ").append(fieldName).append(";\n");
            if (!typeCanBeNull(trueType)) {
                out.append(indent()).append("set").append(capName).append("IsSet(true);\n");
            }
            if (!beanStyle) {
                out.append(indent()).append("return this;\n");
            }
            indentLevel--;
            out.append(indent()).append("}\n\n");
        }
    }

    private void generateUnsetter(FieldNode field, TypeNode trueType, String fieldName, String capName) {
        out.append(indent()).append("public void unset").append(capName).append("() {\n");
        indentLevel++;
        if (typeCanBeNull(trueType)) {
            out.append(indent()).append("this.").append(fieldName).append(" = null;\n");
        } else {
            IssetType issetTypeEnum = needsIsset(this.structLikeNode);
            String issetIdentifier = issetTypeEnum == IssetType.BITSET ? "__isset_bit_vector" : "__isset_bitfield";
            String clearBitMethod = issetTypeEnum == IssetType.BITSET ? ".clear(" : " = org.apache.thrift.EncodingUtils.clearBit(";
            String clearBitParam = issetFieldId(field);
            String closingClear = issetTypeEnum == IssetType.BITSET ? ")" : ", " + clearBitParam + ")";

            if (issetTypeEnum != IssetType.NONE) {
                out.append(indent()).append(issetIdentifier).append(clearBitMethod);
                if (issetTypeEnum == IssetType.PRIMITIVE) out.append(issetIdentifier).append(", ");
                out.append(clearBitParam);
                if (issetTypeEnum == IssetType.PRIMITIVE) out.append(")");
                out.append(";\n");
            }
        }
        indentLevel--;
        out.append(indent()).append("}\n\n");
    }

    private void generateIsSetMethod(FieldNode field, TypeNode trueType, String fieldName, String capName) {
        out.append(indent()).append("/** Returns true if field ").append(fieldName).append(" is set (has been assigned a value) and false otherwise */\n");
        out.append(indent()).append("public boolean isSet").append(capName).append("() {\n");
        indentLevel++;
        if (typeCanBeNull(trueType)) {
            out.append(indent()).append("return this.").append(fieldName).append(" != null;\n");
        } else {
            IssetType issetTypeEnum = needsIsset(this.structLikeNode);
            if (issetTypeEnum == IssetType.NONE) {
                out.append(indent()).append("return false; // Should not happen if type cannot be null and no isset bits\n");
            } else {
                String issetIdentifier = issetTypeEnum == IssetType.BITSET ? "__isset_bit_vector" : "__isset_bitfield";
                String testBitMethod = issetTypeEnum == IssetType.BITSET ? ".get(" : "org.apache.thrift.EncodingUtils.testBit(";
                String testBitParam = issetFieldId(field);
                String closingTest = issetTypeEnum == IssetType.BITSET ? ")" : ")"; // Corrected for PRIMITIVE

                out.append(indent()).append("return ").append(testBitMethod);
                if (issetTypeEnum == IssetType.PRIMITIVE) {
                    out.append(issetIdentifier).append(", ").append(testBitParam).append(closingTest).append(";\n");
                } else { // BITSET
                    out.append(testBitParam).append(closingTest).append(";\n");
                }
            }
        }
        indentLevel--;
        out.append(indent()).append("}\n\n");
    }

    private void generateSetIsSetMethod(FieldNode field, TypeNode trueType, String fieldName, String capName) {
        out.append(indent()).append("public void set").append(capName).append("IsSet(boolean value) {\n");
        indentLevel++;
        if (typeCanBeNull(trueType)) {
            out.append(indent()).append("if (!value) {\n");
            indentLevel++;
            out.append(indent()).append("this.").append(fieldName).append(" = null;\n");
            indentLevel--;
            out.append(indent()).append("}\n");
        } else {
            IssetType issetTypeEnum = needsIsset(this.structLikeNode);
            if (issetTypeEnum != IssetType.NONE) {
                String issetIdentifier = issetTypeEnum == IssetType.BITSET ? "__isset_bit_vector" : "__isset_bitfield";
                String setBitMethod = issetTypeEnum == IssetType.BITSET ? ".set(" : " = org.apache.thrift.EncodingUtils.setBit(";
                String setBitParam = issetFieldId(field);
                String closingSet = issetTypeEnum == IssetType.BITSET ? ", value)" : ", value)"; // Corrected for PRIMITIVE

                out.append(indent()).append(issetIdentifier).append(setBitMethod);
                if (issetTypeEnum == IssetType.PRIMITIVE) {
                    out.append(issetIdentifier).append(", ").append(setBitParam).append(closingSet).append(";\n");
                } else { // BITSET
                    out.append(setBitParam).append(closingSet).append(";\n");
                }
            }
        }
        indentLevel--;
        out.append(indent()).append("}\n\n");
    }

    private void generateJavaStructEquality(StructLikeNode struct) {
        generateEqualsObjectMethod(struct);
        generateEqualsTypedMethod(struct);
        generateHashCodeMethod(struct);
    }

    private void generateEqualsObjectMethod(StructLikeNode struct) {
        String structName = getEffectiveJavaIdentifier(struct.getName());
        out.append(indent()).append(javaOverrideAnnotation()).append("\n");
        out.append(indent()).append("public boolean equals(java.lang.Object that) {\n");
        indentLevel++;
        out.append(indent()).append("if (that instanceof ").append(structName).append(")\n");
        indentLevel++;
        out.append(indent()).append("return this.equals((").append(structName).append(")that);\n");
        indentLevel--;
        out.append(indent()).append("return false;\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");
    }

    private void generateEqualsTypedMethod(StructLikeNode struct) {
        String structName = getEffectiveJavaIdentifier(struct.getName());
        out.append(indent()).append("public boolean equals(").append(structName).append(" that) {\n");
        indentLevel++;
        out.append(indent()).append("if (that == null)\n");
        indentLevel++;
        out.append(indent()).append("return false;\n");
        indentLevel--;
        out.append(indent()).append("if (this == that)\n");
        indentLevel++;
        out.append(indent()).append("return true;\n");
        indentLevel--;

        for (FieldNode field : struct.getFields()) {
            String originalFieldName = field.getName(); // Use original name
            TypeNode fieldType = field.getType();       // Use original type

            String capName = capitalizedName(originalFieldName); // Pass original name
            TypeNode trueType = getTrueType(fieldType);

            out.append("\n");
            out.append(indent()).append("boolean this_present_").append(originalFieldName).append(" = this.isSet").append(capName).append("();\n");
            out.append(indent()).append("boolean that_present_").append(originalFieldName).append(" = that.isSet").append(capName).append("();\n");
            out.append(indent()).append("if (this_present_").append(originalFieldName).append(" || that_present_").append(originalFieldName).append(") {\n");
            indentLevel++;
            out.append(indent()).append("if (!(this_present_").append(originalFieldName).append(" && that_present_").append(originalFieldName).append("))\n");
            indentLevel++;
            out.append(indent()).append("return false;\n");
            indentLevel--;

            String thisFieldValue = "this." + originalFieldName;
            String thatFieldValue = "that." + originalFieldName;
            String comparison;

            if (trueType.isBinary() || !typeCanBeNull(trueType) && !trueType.isBaseType()) {
                comparison = "!" + thisFieldValue + ".equals(" + thatFieldValue + ")";
            } else if (typeCanBeNull(trueType) && !trueType.isBaseType()) {
                comparison = "!" + thisFieldValue + ".equals(" + thatFieldValue + ")";
            }
            else {
                comparison = thisFieldValue + " != " + thatFieldValue;
            }
            out.append(indent()).append("if (").append(comparison).append(")\n");
            indentLevel++;
            out.append(indent()).append("return false;\n");
            indentLevel--;
            indentLevel--;
            out.append(indent()).append("}\n");
        }
        out.append("\n");
        out.append(indent()).append("return true;\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");
    }

    private void generateHashCodeMethod(StructLikeNode struct) {
        out.append(indent()).append(javaOverrideAnnotation()).append("\n");
        out.append(indent()).append("public int hashCode() {\n");
        indentLevel++;
        out.append(indent()).append("java.util.List<java.lang.Object> list = new java.util.ArrayList<java.lang.Object>();\n");

        for (FieldNode field : struct.getFields()) {
            String originalFieldName = field.getName(); // Use original name
            TypeNode fieldType = field.getType();       // Use original type

            String capName = capitalizedName(originalFieldName); // Pass original name
            TypeNode trueType = getTrueType(fieldType);

            out.append(indent()).append("boolean present_").append(originalFieldName).append(" = isSet").append(capName).append("();\n");
            out.append(indent()).append("list.add(present_").append(originalFieldName).append(");\n");
            out.append(indent()).append("if (present_").append(originalFieldName).append(") {\n");
            indentLevel++;

            String fieldValue = "this." + originalFieldName;
            if (trueType.isEnum()) {
                out.append(indent()).append("list.add(").append(fieldValue).append(".getValue());\n");
            } else if (trueType.isBaseType()) {
                String baseName = trueType.getName();
                if (trueType.isBinary()) baseName = "binary";

                switch (baseName) {
                    case "bool":
                        out.append(indent()).append("list.add(").append(fieldValue).append(" ? 1 : 0); \n");
                        break;
                    case "byte": case "i8":
                    case "short": case "i16":
                    case "int": case "i32":
                        out.append(indent()).append("list.add(").append(fieldValue).append(");\n");
                        break;
                    case "long": case "i64":
                    case "double":
                        out.append(indent()).append("list.add(").append(fieldValue).append(");\n");
                        break;
                    case "string":
                    case "uuid":
                    case "binary": // ByteBuffer's hashCode is fine
                        out.append(indent()).append("list.add(").append(fieldValue).append(");\n");
                        break;
                    default:
                        out.append(indent()).append("list.add(0); // Unhandled base type in hashCode: ").append(baseName).append("\n");
                        break;
                }
            } else {
                out.append(indent()).append("list.add(").append(fieldValue).append(");\n");
            }
            indentLevel--;
            out.append(indent()).append("}\n");
        }
        out.append(indent()).append("return list.hashCode();\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");
    }

    private void generateJavaStructCompareTo(StructLikeNode struct) {
        String structName = getEffectiveJavaIdentifier(struct.getName());
        out.append(indent()).append(javaOverrideAnnotation()).append("\n");
        out.append(indent()).append("public int compareTo(").append(structName).append(" other) {\n");
        indentLevel++;

        out.append(indent()).append("if (!getClass().equals(other.getClass())) {\n");
        indentLevel++;
        out.append(indent()).append("return getClass().getName().compareTo(other.getClass().getName());\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");

        out.append(indent()).append("int lastComparison = 0;\n\n");

        for (FieldNode field : struct.getFields()) {
            String originalFieldName = field.getName(); // Use original name
            String capName = capitalizedName(originalFieldName); // Pass original name

            out.append(indent()).append("lastComparison = java.lang.Boolean.compare(isSet").append(capName).append("(), other.isSet").append(capName).append("());\n");
            out.append(indent()).append("if (lastComparison != 0) {\n");
            indentLevel++;
            out.append(indent()).append("return lastComparison;\n");
            indentLevel--;
            out.append(indent()).append("}\n");

            out.append(indent()).append("if (isSet").append(capName).append("()) {\n");
            indentLevel++;
            out.append(indent()).append("lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.").append(originalFieldName).append(", other.").append(originalFieldName).append(");\n");
            out.append(indent()).append("if (lastComparison != 0) {\n");
            indentLevel++;
            out.append(indent()).append("return lastComparison;\n");
            indentLevel--;
            out.append(indent()).append("}\n");
            indentLevel--;
            out.append(indent()).append("}\n");
        }

        out.append(indent()).append("return 0;\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");
    }

    private void generateJavaStructFieldById(StructLikeNode struct) {
        out.append(indent()).append(javaNullableAnnotation()).append("\n");
        out.append(indent()).append(javaOverrideAnnotation()).append("\n");
        out.append(indent()).append("public _Fields fieldForId(int fieldId) {\n");
        indentLevel++;
        out.append(indent()).append("return _Fields.findByThriftId(fieldId);\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");
    }

    private void generateSetFieldValueMethod(StructLikeNode struct) {
        out.append(indent()).append(javaOverrideAnnotation()).append("\n");
        out.append(indent()).append("public void setFieldValue(_Fields field, ")
                .append(javaNullableAnnotation()).append(" java.lang.Object value) {\n");
        indentLevel++;
        out.append(indent()).append("switch (field) {\n");

        boolean firstCaseSetField = true;
        for (FieldNode fieldNode : struct.getFields()) {
            if (!firstCaseSetField) {
                out.append("\n");
            }
            firstCaseSetField = false;

            String originalFieldName = fieldNode.getName(); // Use original name
            String capName = capitalizedName(originalFieldName); // Pass original name
            TypeNode fieldType = fieldNode.getType(); // Use original type

            TypeNode trueType = getTrueType(fieldType);

            out.append(indent()).append("case ").append(constantName(originalFieldName).toUpperCase()).append(":\n");
            indentLevel++;
            out.append(indent()).append("if (value == null) {\n");
            indentLevel++;
            out.append(indent()).append("unset").append(capName).append("();\n");
            indentLevel--;
            out.append(indent()).append("} else {\n");
            indentLevel++;
            // Determine the correct Java type for casting
            String javaCastType = getTypeName(trueType, true, false, false, false); // Use wrapper for primitives
            out.append(indent()).append("set").append(capName).append("((").append(javaCastType)
                    .append(")value);\n");
            indentLevel--;
            out.append(indent()).append("}\n");
            out.append(indent()).append("break;\n");
            indentLevel--;
        }

        out.append("\n"); // RE-ADD blank line for setFieldValue only
        out.append(indent()).append("}\n"); // end switch
        indentLevel--;
        out.append(indent()).append("}\n\n");
    }

    private void generateGetFieldValueMethod(StructLikeNode struct) {
        out.append(indent()).append(javaNullableAnnotation()).append("\n");
        out.append(indent()).append(javaOverrideAnnotation()).append("\n");
        out.append(indent()).append("public java.lang.Object getFieldValue(_Fields field) {\n");
        indentLevel++;
        out.append(indent()).append("switch (field) {\n");

        boolean firstCaseGetField = true;
        for (FieldNode fieldNode : struct.getFields()) {
            if (!firstCaseGetField) {
                out.append("\n");
            }
            firstCaseGetField = false;

            String originalFieldName = fieldNode.getName(); // Use original name
            String capName = capitalizedName(originalFieldName); // Pass original name
            TypeNode fieldType = fieldNode.getType(); // Use original type

            TypeNode trueType = getTrueType(fieldType);

            out.append(indent()).append("case ").append(constantName(originalFieldName).toUpperCase()).append(":\n");
            indentLevel++;
            String getterName = (trueType.isBaseType() && "bool".equals(trueType.getName())) ?
                    "is" + capName : "get" + capName;
            out.append(indent()).append("return ").append(getterName).append("();\n");
            indentLevel--;
        }

        out.append("\n"); // Add blank line before switch closing brace
        out.append(indent()).append("}\n"); // end switch
        out.append(indent()).append("throw new java.lang.IllegalStateException();\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");
    }

    private void generateIsSetFieldMethod(StructLikeNode struct) {
        out.append(indent()).append("/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */\n");
        out.append(indent()).append(javaOverrideAnnotation()).append("\n");
        out.append(indent()).append("public boolean isSet(_Fields field) {\n");
        indentLevel++;
        out.append(indent()).append("if (field == null) {\n");
        indentLevel++;
        out.append(indent()).append("throw new java.lang.IllegalArgumentException();\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");
        out.append(indent()).append("switch (field) {\n");

        boolean firstCaseIsSet = true;
        for (FieldNode fieldNode : struct.getFields()) {
            if (!firstCaseIsSet) {
                out.append("\n");
            }
            firstCaseIsSet = false;

            String originalFieldName = fieldNode.getName(); // Use original name
            String capName = capitalizedName(originalFieldName); // Pass original name
            out.append(indent()).append("case ").append(constantName(originalFieldName).toUpperCase()).append(":\n");
            indentLevel++;
            out.append(indent()).append("return isSet").append(capName).append("();\n");
            indentLevel--;
        }

        out.append("\n"); // Add blank line before switch closing brace
        out.append(indent()).append("}\n"); // end switch
        out.append(indent()).append("throw new java.lang.IllegalStateException();\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");
    }

    private void generateJavaStructReader(StructLikeNode struct) {
        out.append(indent()).append(javaOverrideAnnotation()).append("\n");
        out.append(indent()).append("public void read(org.apache.thrift.protocol.TProtocol iprot) throws ")
                .append("org.apache.thrift.TException {\n");
        indentLevel++;
        out.append(indent()).append("scheme(iprot).read(iprot, this);\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");
    }

    private void generateJavaStructResultWriter(StructLikeNode struct) {
        out.append(indent()).append("public void write(org.apache.thrift.protocol.TProtocol oprot) throws ")
                .append("org.apache.thrift.TException {\n");
        indentLevel++;
        out.append(indent()).append("scheme(oprot).write(oprot, this);\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");
    }

    private void generateJavaStructWriter(StructLikeNode struct) {
        out.append(indent()).append(javaOverrideAnnotation()).append("\n");
        out.append(indent()).append("public void write(org.apache.thrift.protocol.TProtocol oprot) throws ")
                .append("org.apache.thrift.TException {\n");
        indentLevel++;
        out.append(indent()).append("scheme(oprot).write(oprot, this);\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");
    }

    private void generateJavaStructToString(StructLikeNode struct) {
        String structName = getEffectiveJavaIdentifier(struct.getName());
        out.append(indent()).append(javaOverrideAnnotation()).append("\n");
        out.append(indent()).append("public java.lang.String toString() {\n");
        indentLevel++;

        out.append(indent()).append("java.lang.StringBuilder sb = new java.lang.StringBuilder(\"").append(structName).append("(\");\n");
        out.append(indent()).append("boolean first = true;\n\n");

        for (FieldNode field : struct.getFields()) {
            String originalFieldName = field.getName(); // Use original name
            TypeNode fieldType = field.getType();       // Use original type

            String capName = capitalizedName(originalFieldName); // Pass original name
            TypeNode trueType = getTrueType(fieldType);
            boolean isOptional = field.getRequirement() == FieldNode.Requirement.OPTIONAL;

            if (isOptional) {
                out.append(indent()).append("if (isSet").append(capName).append("()) {\n");
                indentLevel++;
            } else {

            }

            out.append(indent()).append("if (!first) sb.append(\", \");\n");
            out.append(indent()).append("sb.append(\"").append(originalFieldName).append(":\");\n");

            out.append(indent()).append("if (this.").append(originalFieldName).append(" == null) {\n");
            indentLevel++;
            out.append(indent()).append("sb.append(\"null\");\n");
            indentLevel--;
            out.append(indent()).append("} else {\n");
            indentLevel++;

            if (trueType.isBinary() && !trueType.isContainer()) {
                out.append(indent()).append("org.apache.thrift.TBaseHelper.toString(this.").append(originalFieldName).append(", sb);\n");
            } else {
                out.append(indent()).append("sb.append(this.").append(originalFieldName).append(");\n");
            }
            indentLevel--;
            out.append(indent()).append("}\n");

            out.append(indent()).append("first = false;\n");

            if (isOptional) {
                indentLevel--;
                out.append(indent()).append("}\n");
            }
        }
        // Ensure that if the first field was optional and not set, we don't have a leading comma problem
        // The logic of `if (!first) sb.append(", ");` handles this naturally.
        // If all fields are optional and none are set, it will be "Point()".
        // If some optional fields are set, they will be correctly comma-separated.

        out.append(indent()).append("sb.append(\")\");\n");
        out.append(indent()).append("return sb.toString();\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");
    }

    private void generateJavaValidator(StructLikeNode struct) {
        out.append(indent()).append("public void validate() throws org.apache.thrift.TException {\n");
        indentLevel++;

        out.append(indent()).append("// check for required fields\n");
        for (FieldNode field : struct.getFields()) {
            if (field.getRequirement() == FieldNode.Requirement.REQUIRED) {
                String originalFieldName = field.getName(); // Use original name
                TypeNode fieldType = field.getType();       // Use original type

                String capName = capitalizedName(originalFieldName); // Pass original name
                TypeNode trueType = getTrueType(fieldType);

                if (beanStyle) {
                    out.append(indent()).append("if (!isSet").append(capName).append("()) {\n");
                    indentLevel++;
                    out.append(indent()).append("throw new org.apache.thrift.protocol.TProtocolException(\"Required field '")
                            .append(originalFieldName).append("' is unset! Struct: \" + toString());\n");
                    indentLevel--;
                    out.append(indent()).append("}\n");
                } else {
                    if (typeCanBeNull(trueType)) {
                        out.append(indent()).append("if (this.").append(originalFieldName).append(" == null) {\n");
                        indentLevel++;
                        out.append(indent()).append("throw new org.apache.thrift.protocol.TProtocolException(\"Required field '")
                                .append(originalFieldName).append("' was not present! Struct: \" + toString());\n");
                        indentLevel--;
                        out.append(indent()).append("}\n");
                    } else {
                        out.append(indent()).append("if (!isSet").append(capName).append("()) {\n");
                        indentLevel++;
                        out.append(indent()).append("throw new org.apache.thrift.protocol.TProtocolException(\"Required field '")
                                .append(originalFieldName).append("' was not found in serialized data! Struct: \" + toString());\n");
                        indentLevel--;
                        out.append(indent()).append("}\n");
                    }
                }
            }
        }
        out.append("\n");

        out.append(indent()).append("// check for sub-struct validity\n");
        for (FieldNode field : struct.getFields()) {
            String originalFieldName = field.getName(); // Use original name
            // TypeNode fieldType = field.getType(); // Not needed here, using originalTrueType

            TypeNode originalTrueType = getTrueType(field.getType());
            if (originalTrueType.isStruct()) {
                out.append(indent()).append("if (this.").append(originalFieldName).append(" != null) {\n");
                indentLevel++;
                out.append(indent()).append("this.").append(originalFieldName).append(".validate();\n");
                indentLevel--;
                out.append(indent()).append("}\n");
            }
        }

        indentLevel--;
        out.append(indent()).append("}\n\n");
    }

    private void generateJavaStructWriteObject(StructLikeNode struct) {
        out.append(indent()).append("private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {\n");
        indentLevel++;
        out.append(indent()).append("try {\n");
        indentLevel++;
        out.append(indent()).append("write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));\n");
        indentLevel--;
        out.append(indent()).append("} catch (org.apache.thrift.TException te) {\n");
        indentLevel++;
        if (androidLegacy) {
            out.append(indent()).append("throw new java.io.IOException(te.getMessage());\n");
        } else {
            out.append(indent()).append("throw new java.io.IOException(te);\n");
        }
        indentLevel--;
        out.append(indent()).append("}\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");
    }

    private void generateJavaStructReadObject(StructLikeNode struct) {
        out.append(indent()).append("private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException {\n");
        indentLevel++;
        out.append(indent()).append("try {\n");
        indentLevel++;
        IssetType issetType = needsIsset(struct); // needsIsset should internally use effective types if needed

        // Check if any field that *requires* isset tracking (primitives) exists
        boolean needsIssetInit = false;
        for(FieldNode f : struct.getFields()){
            TypeNode fieldType = f.getType(); // Use original type
            // if(f.getName().equals("yy")) fieldType = new BaseTypeNode(BaseTypeNode.BaseTypeEnum.DOUBLE); // REMOVE Hack
            if(!typeCanBeNull(fieldType)){
                needsIssetInit = true;
                break;
            }
        }

        if (needsIssetInit) {
            switch (issetType) {
                case PRIMITIVE:
                    out.append(indent()).append("__isset_bitfield = 0;\n");
                    break;
                case BITSET:
                    out.append(indent()).append("__isset_bit_vector = new java.util.BitSet(1);\n"); // As per C++ ref
                    break;
                case NONE:
                    break;
            }
        }
        out.append(indent()).append("read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));\n");
        indentLevel--;
        out.append(indent()).append("} catch (org.apache.thrift.TException te) {\n");
        indentLevel++;
        if (androidLegacy) {
            out.append(indent()).append("throw new java.io.IOException(te.getMessage());\n");
        } else {
            out.append(indent()).append("throw new java.io.IOException(te);\n");
        }
        indentLevel--;
        out.append(indent()).append("}\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");
    }

    private void generateJavaStructStandardScheme(StructLikeNode structNode, boolean isResult) {
        String structName = getEffectiveJavaIdentifier(structNode.getName());
        String capStructName = capitalizedName(structName);

        out.append(indent()).append("private static class ").append(capStructName).append("StandardSchemeFactory implements org.apache.thrift.scheme.SchemeFactory {\n");
        indentLevel++;
        out.append(indent()).append(javaOverrideAnnotation()).append("\n");
        out.append(indent()).append("public ").append(capStructName).append("StandardScheme getScheme() {\n");
        indentLevel++;
        out.append(indent()).append("return new ").append(capStructName).append("StandardScheme();\n");
        indentLevel--;
        out.append(indent()).append("}\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");

        out.append(indent()).append("private static class ").append(capStructName).append("StandardScheme extends org.apache.thrift.scheme.StandardScheme<").append(structName).append("> {\n");
        indentLevel++;

        out.append(indent()).append(javaOverrideAnnotation()).append("\n");
        out.append(indent()).append("public void read(org.apache.thrift.protocol.TProtocol iprot, ").append(structName).append(" struct) throws org.apache.thrift.TException {\n");
        indentLevel++;
        out.append(indent()).append("org.apache.thrift.protocol.TField schemeField;\n");
        out.append(indent()).append("iprot.readStructBegin();\n");
        out.append(indent()).append("while (true)\n");
        out.append(indent()).append("{\n");
        indentLevel++;
        out.append(indent()).append("schemeField = iprot.readFieldBegin();\n");
        out.append(indent()).append("if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { \n");
        indentLevel++;
        out.append(indent()).append("break;\n");
        indentLevel--;
        out.append(indent()).append("}\n");
        out.append(indent()).append("switch (schemeField.id) {\n");
        for (FieldNode field : structNode.getFields()) {
            String originalFieldName = field.getName(); // Use original name
            String fieldConstName = constantName(originalFieldName).toUpperCase();
            out.append(indent()).append("  case ").append(field.getId()).append(": // ").append(fieldConstName).append("\n");
            indentLevel++;
            out.append(indent()).append("if (schemeField.type == ").append(fieldConstName).append("_FIELD_DESC.type) {\n");
            indentLevel++;
            generateStandardSchemeDeserializerLogic(field, "struct");
            out.append(indent()).append("struct.set").append(capitalizedName(originalFieldName)).append("IsSet(true);\n");
            indentLevel--;
            out.append(indent()).append("} else { \n");
            indentLevel++;
            out.append(indent()).append("org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);\n");
            indentLevel--;
            out.append(indent()).append("}\n");
            out.append(indent()).append("break;\n");
            indentLevel--;
        }
        out.append(indent()).append("  default:\n");
        indentLevel++;
        out.append(indent()).append("org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);\n");
        indentLevel--;
        out.append(indent()).append("}\n");
        out.append(indent()).append("iprot.readFieldEnd();\n");
        indentLevel--;
        out.append(indent()).append("}\n");
        out.append(indent()).append("iprot.readStructEnd();\n");

        if (!beanStyle) {
            out.append(indent()).append("// check for required fields of primitive type, which can't be checked in the validate method\n");
            for (FieldNode field : structNode.getFields()) {
                TypeNode fieldType = field.getType(); // Use original type
                if (field.getRequirement() == FieldNode.Requirement.REQUIRED && isPrimitiveType(fieldType)) {
                    out.append(indent()).append("if (!struct.isSet").append(capitalizedName(field.getName())).append("()) {\n");
                    indentLevel++;
                    out.append(indent()).append("throw new org.apache.thrift.protocol.TProtocolException(\"Required field '")
                            .append(field.getName()).append("' was not found in serialized data! Struct: \" + struct.toString());\n");
                    indentLevel--;
                    out.append(indent()).append("}\n");
                }
            }
        }
        out.append(indent()).append("struct.validate();\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");

        out.append(indent()).append(javaOverrideAnnotation()).append("\n");
        out.append(indent()).append("public void write(org.apache.thrift.protocol.TProtocol oprot, ").append(structName).append(" struct) throws org.apache.thrift.TException {\n");
        indentLevel++;
        out.append(indent()).append("struct.validate();\n\n");
        out.append(indent()).append("oprot.writeStructBegin(STRUCT_DESC);\n");
        for (FieldNode field : structNode.getFields()) {
            String originalFieldName = field.getName(); // Use original name
            String capFieldName = capitalizedName(originalFieldName); // Pass original name
            TypeNode fieldType = field.getType();       // Use original type

            // Determine if the field should be written
            boolean shouldWrite = false;
            if (field.getRequirement() == FieldNode.Requirement.OPTIONAL) {
                // Optional fields are written if they are set
                out.append(indent()).append("if (struct.isSet").append(capFieldName).append("()) {\n");
                indentLevel++;
                shouldWrite = true; // Will be written inside this block
            } else if (typeCanBeNull(fieldType)) {
                // Required or default fields that can be null are written if non-null
                out.append(indent()).append("if (struct.").append(originalFieldName).append(" != null) {\n");
                indentLevel++;
                shouldWrite = true; // Will be written inside this block
            } else {
                // Required or default primitive fields are always written
                shouldWrite = true;
            }

            if (shouldWrite) {
                out.append(indent()).append("oprot.writeFieldBegin(").append(constantName(originalFieldName).toUpperCase()).append("_FIELD_DESC);\n");
                generateStandardSchemeSerializerLogic(field, "struct");
                out.append(indent()).append("oprot.writeFieldEnd();\n");
            }

            // Close if blocks for optional/nullable fields
            if (field.getRequirement() == FieldNode.Requirement.OPTIONAL || typeCanBeNull(fieldType)) {
                if(shouldWrite) indentLevel--; // Only decrement if we incremented due to shouldWrite block
                out.append(indent()).append("}\n");
            }
        }
        out.append(indent()).append("oprot.writeFieldStop();\n");
        out.append(indent()).append("oprot.writeStructEnd();\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");

        indentLevel--;
        out.append(indent()).append("}\n\n");
    }

    private void generateJavaStructTupleScheme(StructLikeNode structNode) {
        String structName = getEffectiveJavaIdentifier(structNode.getName());
        String capStructName = capitalizedName(structName);

        out.append(indent()).append("private static class ").append(capStructName).append("TupleSchemeFactory implements org.apache.thrift.scheme.SchemeFactory {\n");
        indentLevel++;
        out.append(indent()).append(javaOverrideAnnotation()).append("\n");
        out.append(indent()).append("public ").append(capStructName).append("TupleScheme getScheme() {\n");
        indentLevel++;
        out.append(indent()).append("return new ").append(capStructName).append("TupleScheme();\n");
        indentLevel--;
        out.append(indent()).append("}\n");
        indentLevel--;
        out.append(indent()).append("}\n\n");

        out.append(indent()).append("private static class ").append(capStructName).append("TupleScheme extends org.apache.thrift.scheme.TupleScheme<").append(structName).append("> {\n");
        indentLevel++;

        out.append(indent()).append(javaOverrideAnnotation()).append("\n");
        out.append(indent()).append("@SuppressWarnings(\"unchecked\")\n"); // For BitSet casting if used broadly
        out.append(indent()).append("public void write(org.apache.thrift.protocol.TProtocol prot, ").append(structName).append(" struct) throws org.apache.thrift.TException {\n");
        indentLevel++;
        out.append(indent()).append("org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;\n");

        List<FieldNode> optionalFields = new ArrayList<>();
        List<FieldNode> requiredFields = new ArrayList<>();

        for (FieldNode field : structNode.getFields()) {
            if (field.getRequirement() == FieldNode.Requirement.OPTIONAL) {
                optionalFields.add(field);
            } else { // REQUIRED or DEFAULT
                requiredFields.add(field);
            }
        }
        // Write required fields first
        for (FieldNode field : requiredFields) {
            generateStandardSchemeSerializerLogic(field, "struct", "oprot");
        }

        if (!optionalFields.isEmpty()) {
            out.append(indent()).append("java.util.BitSet optionals = new java.util.BitSet();\n");
            for (int i = 0; i < optionalFields.size(); i++) {
                FieldNode field = optionalFields.get(i);
                String originalFieldName = field.getName(); // Use original name
                out.append(indent()).append("if (struct.isSet").append(capitalizedName(originalFieldName)).append("()) {\n");
                indentLevel++;
                out.append(indent()).append("optionals.set(").append(i).append(");\n");
                indentLevel--;
                out.append(indent()).append("}\n");
            }
            out.append(indent()).append("oprot.writeBitSet(optionals, ").append(optionalFields.size()).append(");\n");
            for (FieldNode field : optionalFields) {
                String originalFieldName = field.getName(); // Use original name
                out.append(indent()).append("if (struct.isSet").append(capitalizedName(originalFieldName)).append("()) {\n");
                indentLevel++;
                generateStandardSchemeSerializerLogic(field, "struct", "oprot");
                indentLevel--;
                out.append(indent()).append("}\n");
            }
        }
        indentLevel--;
        out.append(indent()).append("}\n\n");

        out.append(indent()).append(javaOverrideAnnotation()).append("\n");
        out.append(indent()).append("public void read(org.apache.thrift.protocol.TProtocol prot, ").append(structName).append(" struct) throws org.apache.thrift.TException {\n");
        indentLevel++;
        out.append(indent()).append("org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;\n");

        optionalFields.clear();
        requiredFields.clear();
        for (FieldNode field : structNode.getFields()) {
            if (field.getRequirement() == FieldNode.Requirement.OPTIONAL) {
                optionalFields.add(field);
            } else {
                requiredFields.add(field);
            }
        }

        for (FieldNode field : requiredFields) {
            String originalFieldName = field.getName(); // Use original name
            generateStandardSchemeDeserializerLogic(field, "struct", "iprot");
            out.append(indent()).append("struct.set").append(capitalizedName(originalFieldName)).append("IsSet(true);\n");
        }

        if (!optionalFields.isEmpty()) {
            out.append(indent()).append("java.util.BitSet incoming = iprot.readBitSet(").append(optionalFields.size()).append(");\n");
            for (int i = 0; i < optionalFields.size(); i++) {
                FieldNode field = optionalFields.get(i);
                String originalFieldName = field.getName(); // Use original name
                out.append(indent()).append("if (incoming.get(").append(i).append(")) {\n");
                indentLevel++;
                generateStandardSchemeDeserializerLogic(field, "struct", "iprot");
                out.append(indent()).append("struct.set").append(capitalizedName(originalFieldName)).append("IsSet(true);\n");
                indentLevel--;
                out.append(indent()).append("}\n");
            }
        }
        indentLevel--;
        out.append(indent()).append("}\n");

        indentLevel--;
        out.append(indent()).append("}\n\n");
    }

    private void generateStandardSchemeDeserializerLogic(FieldNode field, String structVarName) {
        generateStandardSchemeDeserializerLogic(field, structVarName, "iprot");
    }

    private void generateStandardSchemeDeserializerLogic(FieldNode field, String structVarName, String protVarName) {
        TypeNode fieldType = field.getType(); // Use original type
        String originalFieldName = field.getName(); // Use original name
        // if (field.getName().equals("yy")) { // REMOVE Hack for test
        //     fieldType = new BaseTypeNode(BaseTypeNode.BaseTypeEnum.DOUBLE);
        // }
        TypeNode trueType = getTrueType(fieldType);

        if (trueType.isBaseType()) {
            String baseName = trueType.getName();
            if (trueType.isBinary()) baseName = "binary";

            switch (baseName) {
                case "bool": out.append(indent()).append(structVarName).append(".").append(originalFieldName).append(" = ").append(protVarName).append(".readBool();\n"); break;
                case "byte": case "i8": out.append(indent()).append(structVarName).append(".").append(originalFieldName).append(" = ").append(protVarName).append(".readByte();\n"); break;
                case "i16": out.append(indent()).append(structVarName).append(".").append(originalFieldName).append(" = ").append(protVarName).append(".readI16();\n"); break;
                case "i32": out.append(indent()).append(structVarName).append(".").append(originalFieldName).append(" = ").append(protVarName).append(".readI32();\n"); break;
                case "i64": out.append(indent()).append(structVarName).append(".").append(originalFieldName).append(" = ").append(protVarName).append(".readI64();\n"); break;
                case "double": out.append(indent()).append(structVarName).append(".").append(originalFieldName).append(" = ").append(protVarName).append(".readDouble();\n"); break;
                case "string": out.append(indent()).append(structVarName).append(".").append(originalFieldName).append(" = ").append(protVarName).append(".readString();\n"); break;
                case "binary": out.append(indent()).append(structVarName).append(".").append(originalFieldName).append(" = ").append(protVarName).append(".readBinary();\n"); break;
                case "uuid": out.append(indent()).append(structVarName).append(".").append(originalFieldName).append(" = ").append(protVarName).append(".readUuid();\n"); break;
                default: throw new RuntimeException("Unhandled base type for deserialization: " + baseName);
            }
        } else if (trueType.isEnum()) {
            out.append(indent()).append(structVarName).append(".").append(originalFieldName).append(" = ").append(getTypeName(trueType)).append(".findByValue(").append(protVarName).append(".readI32());\n");
        } else if (trueType.isStruct() || trueType.isException()) {
            out.append(indent()).append(structVarName).append(".").append(originalFieldName).append(" = new ").append(getTypeName(trueType)).append("();\n");
            out.append(indent()).append(structVarName).append(".").append(originalFieldName).append(".read(").append(protVarName).append(");\n");
        } else if (trueType.isContainer()) {
            deserializeContainer(trueType, originalFieldName, structVarName, protVarName); // Pass original name
        } else {
            throw new RuntimeException("Unhandled type for deserialization: " + trueType.getName());
        }
    }

    private void generateStandardSchemeSerializerLogic(FieldNode field, String structVarName) {
        generateStandardSchemeSerializerLogic(field, structVarName, "oprot");
    }

    private void generateStandardSchemeSerializerLogic(FieldNode field, String structVarName, String protVarName) {
        TypeNode fieldType = field.getType(); // Use original type
        String originalFieldName = field.getName(); // Use original name
        //  if (field.getName().equals("yy")) { // REMOVE Hack for test
        //     fieldType = new BaseTypeNode(BaseTypeNode.BaseTypeEnum.DOUBLE);
        // }
        TypeNode trueType = getTrueType(fieldType);

        if (trueType.isBaseType()) {
            String baseName = trueType.getName();
            if (trueType.isBinary()) baseName = "binary";

            switch (baseName) {
                case "bool": out.append(indent()).append(protVarName).append(".writeBool(").append(structVarName).append(".").append(originalFieldName).append(");\n"); break;
                case "byte": case "i8": out.append(indent()).append(protVarName).append(".writeByte(").append(structVarName).append(".").append(originalFieldName).append(");\n"); break;
                case "i16": out.append(indent()).append(protVarName).append(".writeI16(").append(structVarName).append(".").append(originalFieldName).append(");\n"); break;
                case "i32": out.append(indent()).append(protVarName).append(".writeI32(").append(structVarName).append(".").append(originalFieldName).append(");\n"); break;
                case "i64": out.append(indent()).append(protVarName).append(".writeI64(").append(structVarName).append(".").append(originalFieldName).append(");\n"); break;
                case "double": out.append(indent()).append(protVarName).append(".writeDouble(").append(structVarName).append(".").append(originalFieldName).append(");\n"); break;
                case "string": out.append(indent()).append(protVarName).append(".writeString(").append(structVarName).append(".").append(originalFieldName).append(");\n"); break;
                case "binary": out.append(indent()).append(protVarName).append(".writeBinary(").append(structVarName).append(".").append(originalFieldName).append(");\n"); break;
                case "uuid": out.append(indent()).append(protVarName).append(".writeUuid(").append(structVarName).append(".").append(originalFieldName).append(");\n"); break;
                default: throw new RuntimeException("Unhandled base type for serialization: " + baseName);
            }
        } else if (trueType.isEnum()) {
            out.append(indent()).append(protVarName).append(".writeI32(").append(structVarName).append(".").append(originalFieldName).append(".getValue());\n");
        } else if (trueType.isStruct() || trueType.isException()) {
            out.append(indent()).append(structVarName).append(".").append(originalFieldName).append(".write(").append(protVarName).append(");\n");
        } else if (trueType.isContainer()) {
            serializeContainer(trueType, originalFieldName, structVarName, protVarName);  // Pass original name
        } else {
            throw new RuntimeException("Unhandled type for serialization: " + trueType.getName());
        }
    }

    private void deserializeContainer(TypeNode containerType, String fieldJavaName, String structVarName, String protVarName) {
        String tmpContainerVar;
        if (containerType.isList()) {
            TypeNode elemType = getTrueType(containerType.getChildNodes().get(0));
            out.append(indent()).append("org.apache.thrift.protocol.TList _list = ").append(protVarName).append(".readListBegin();\n");
            out.append(indent()).append(structVarName).append(".").append(fieldJavaName).append(" = new ").append(getTypeName(containerType, false, true, false, false)).append("(_list.size);\n");
            tmpContainerVar = getTypeName(elemType, true, false, false, true) + " _elem";
            out.append(indent()).append("for (int _i = 0; _i < _list.size; ++_i)\n");
        } else if (containerType.isSet()) {
            TypeNode elemType = getTrueType(containerType.getChildNodes().get(0));
            out.append(indent()).append("org.apache.thrift.protocol.TSet _set = ").append(protVarName).append(".readSetBegin();\n");
            String initTypeName = getTypeName(containerType, false, true, false, false);
            if (initTypeName.contains("EnumSet")) {
                out.append(indent()).append(structVarName).append(".").append(fieldJavaName).append(" = ").append(initTypeName).append(".noneOf(").append(getTypeName(elemType, true, false, true, true)).append(");\n");
            } else {
                out.append(indent()).append(structVarName).append(".").append(fieldJavaName).append(" = new ").append(initTypeName).append("(_set.size);\n");
            }
            tmpContainerVar = getTypeName(elemType, true, false, false, true) + " _elem";
            out.append(indent()).append("for (int _i = 0; _i < _set.size; ++_i)\n");
        } else if (containerType.isMap()) {
            TypeNode keyType = getTrueType(containerType.getChildNodes().get(0));
            TypeNode valType = getTrueType(containerType.getChildNodes().get(1));
            out.append(indent()).append("org.apache.thrift.protocol.TMap _map = ").append(protVarName).append(".readMapBegin();\n");
            String initTypeName = getTypeName(containerType, false, true, false, false);
            if (initTypeName.contains("EnumMap")) {
                out.append(indent()).append(structVarName).append(".").append(fieldJavaName).append(" = new ").append(initTypeName).append("(").append(getTypeName(keyType, true, false, true, true)).append(");\n");
            } else {
                out.append(indent()).append(structVarName).append(".").append(fieldJavaName).append(" = new ").append(initTypeName).append("(2*_map.size);\n");
            }
            String tmpKeyVar = getTypeName(keyType, true, false, false, true) + " _key";
            String tmpValVar = getTypeName(valType, true, false, false, true) + " _val";
            out.append(indent()).append(tmpKeyVar).append(";\n");
            out.append(indent()).append(tmpValVar).append(";\n");
            out.append(indent()).append("for (int _i = 0; _i < _map.size; ++_i)\n");
            indentLevel++;
            generateStandardSchemeDeserializerLogic(new FieldNode(keyType, "_key"), "", protVarName);
            generateStandardSchemeDeserializerLogic(new FieldNode(valType, "_val"), "", protVarName);
            out.append(indent()).append(structVarName).append(".").append(fieldJavaName).append(".put(_key, _val);\n");
            indentLevel--;
            out.append(indent()).append("}\n");
            out.append(indent()).append(protVarName).append(".readMapEnd();\n");
            return;
        } else {
            throw new RuntimeException("Unknown container type for deserialization: " + containerType.getName());
        }

        indentLevel++;
        out.append(indent()).append("{\n");
        indentLevel++;
        out.append(indent()).append(tmpContainerVar).append(";\n");
        generateStandardSchemeDeserializerLogic(new FieldNode(getTrueType(containerType.getChildNodes().get(0)), "_elem"), "", protVarName);
        out.append(indent()).append(structVarName).append(".").append(fieldJavaName).append(".add(_elem);\n");
        indentLevel--;
        out.append(indent()).append("}\n");
        indentLevel--;
        out.append(indent()).append("}\n");
        if (containerType.isList()) out.append(indent()).append(protVarName).append(".readListEnd();\n");
        if (containerType.isSet()) out.append(indent()).append(protVarName).append(".readSetEnd();\n");
    }

    private void serializeContainer(TypeNode containerType, String fieldJavaName, String structVarName, String protVarName) {
        if (containerType.isList()) {
            TypeNode elemType = getTrueType(containerType.getChildNodes().get(0));
            out.append(indent()).append(protVarName).append(".writeListBegin(new org.apache.thrift.protocol.TList(").append(typeToEnum(elemType)).append(", ").append(structVarName).append(".").append(fieldJavaName).append(".size()));\n");
            out.append(indent()).append("for (").append(getTypeName(elemType, true, false, false, true)).append(" _iter : ").append(structVarName).append(".").append(fieldJavaName).append(")\n");
            indentLevel++;
            out.append(indent()).append("{\n");
            indentLevel++;
            generateStandardSchemeSerializerLogic(new FieldNode(elemType, "_iter"), "", protVarName);
            indentLevel--;
            out.append(indent()).append("}\n");
            indentLevel--;
            out.append(indent()).append(protVarName).append(".writeListEnd();\n");
        } else if (containerType.isSet()) {
            TypeNode elemType = getTrueType(containerType.getChildNodes().get(0));
            out.append(indent()).append(protVarName).append(".writeSetBegin(new org.apache.thrift.protocol.TSet(").append(typeToEnum(elemType)).append(", ").append(structVarName).append(".").append(fieldJavaName).append(".size()));\n");
            out.append(indent()).append("for (").append(getTypeName(elemType, true, false, false, true)).append(" _iter : ").append(structVarName).append(".").append(fieldJavaName).append(")\n");
            indentLevel++;
            out.append(indent()).append("{\n");
            indentLevel++;
            generateStandardSchemeSerializerLogic(new FieldNode(elemType, "_iter"), "", protVarName);
            indentLevel--;
            out.append(indent()).append("}\n");
            indentLevel--;
            out.append(indent()).append(protVarName).append(".writeSetEnd();\n");
        } else if (containerType.isMap()) {
            TypeNode keyType = getTrueType(containerType.getChildNodes().get(0));
            TypeNode valType = getTrueType(containerType.getChildNodes().get(1));
            out.append(indent()).append(protVarName).append(".writeMapBegin(new org.apache.thrift.protocol.TMap(").append(typeToEnum(keyType)).append(", ").append(typeToEnum(valType)).append(", ").append(structVarName).append(".").append(fieldJavaName).append(".size()));\n");
            out.append(indent()).append("for (java.util.Map.Entry<").append(getTypeName(keyType, true, false, false, true)).append(", ").append(getTypeName(valType, true, false, false, true)).append("> _iter : ").append(structVarName).append(".").append(fieldJavaName).append(".entrySet())\n");
            indentLevel++;
            out.append(indent()).append("{\n");
            indentLevel++;
            generateStandardSchemeSerializerLogic(new FieldNode(keyType, "_iter.getKey()"), "", protVarName);
            generateStandardSchemeSerializerLogic(new FieldNode(valType, "_iter.getValue()"), "", protVarName);
            indentLevel--;
            out.append(indent()).append("}\n");
            indentLevel--;
            out.append(indent()).append(protVarName).append(".writeMapEnd();\n");
        } else {
            throw new RuntimeException("Unknown container type for serialization: " + containerType.getName());
        }
    }

    /**
     * Generate scheme lookup method
     */
    private void generateJavaSchemeLookup() {
        out.append(indent()).append("private static <S extends org.apache.thrift.scheme.IScheme> S scheme(")
                .append("org.apache.thrift.protocol.TProtocol proto) {\n");
        indentLevel++;

        out.append(indent()).append("return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ")
                .append("? STANDARD_SCHEME_FACTORY ")
                .append(": TUPLE_SCHEME_FACTORY")
                .append(").getScheme();\n");

        indentLevel--;
        out.append(indent()).append("}\n");
    }

    /**
     * Generate Android Parcelable implementation
     */
    private void generateJavaStructParcelable(StructLikeNode struct) {
        // TODO: Implement this method
        out.append(indent()).append("// TODO: Generate Android Parcelable implementation\n");
    }

    /**
     * Helper method to generate Java documentation for StructLikeNode
     */
    private void generateJavaDoc(StructLikeNode node) {
        // AST Node does not provide getDocstring() currently.
        // Silently skipping Javadoc generation for StructLikeNode.
    }

    /**
     * Helper method to generate Java documentation for FieldNode
     */
    private void generateJavaDoc(FieldNode node) {
        // AST Node does not provide getDocstring() currently.
        // Silently skipping Javadoc generation for FieldNode.
    }

    /**
     * Generate @Generated annotation for a class
     */
    private void generateJavaxGeneratedAnnotation() {
        String summary = getAutogenSummary();
        if (jakartaAnnotations) {
            out.append(indent()).append("@jakarta.annotation.Generated(value = \"").append(summary).append("\"");
        } else {
            out.append(indent()).append("@javax.annotation.Generated(value = \"").append(summary).append("\"");
        }

        if (undatedGeneratedAnnotations) {
            out.append(")\n");
        } else {
            out.append(", date = \"").append(this.date).append("\")\n");
        }
    }

    /**
     * Get standard Java suppressions annotation
     */
    private String getJavaSuppressWarnings() {
        return "@SuppressWarnings({\"cast\", \"rawtypes\", \"serial\", \"unchecked\", \"unused\"})";
    }

    /**
     * Get the standard auto-generation summary string
     */
    private String getAutogenSummary() {
        return "Autogenerated by Thrift Compiler (0.20.0)";
    }

    /**
     * Get the Java Override annotation
     */
    private String javaOverrideAnnotation() {
        return "@Override";
    }

    /**
     * Get the Java Nullable annotation
     */
    private String javaNullableAnnotation() {
        return "@org.apache.thrift.annotation.Nullable";
    }

    /**
     * Convert a field name to constant case
     */
    private String constantName(String name) {
        StringBuilder constantName = new StringBuilder();
        boolean isFirst = true;
        boolean wasPreviousCharUpper = false;
        for (char c : name.toCharArray()) {
            boolean isUpper = Character.isUpperCase(c);
            if (isUpper && !isFirst && !wasPreviousCharUpper) {
                constantName.append('_');
            }
            constantName.append(Character.toUpperCase(c));
            isFirst = false;
            wasPreviousCharUpper = isUpper;
        }
        return constantName.toString();
    }

    /**
     * Get the field id for isset tracking
     */
    private String issetFieldId(FieldNode field) {
        String originalFieldName = field.getName(); // Use original name
        return "__" + constantName(originalFieldName).toUpperCase() + "_ISSET_ID";
    }

    /**
     * Determine if a type can be null
     */
    private boolean typeCanBeNull(TypeNode type) {
        TypeNode trueType = getTrueType(type);
        if (trueType.isContainer() || trueType.isStruct() || trueType.isException() || trueType.isEnum()) {
            return true;
        }
        if (trueType.isBaseType()) {
            return "string".equals(trueType.getName()) ||
                    "uuid".equals(trueType.getName()) ||
                    trueType.isBinary();
        }
        return false;
    }

    /**
     * Check if a type is primitive (maps to a Java primitive type).
     */
    private boolean isPrimitiveType(TypeNode type) {
        TypeNode trueType = getTrueType(type);
        if (trueType.isBaseType()) {
            String baseName = trueType.getName();
            switch (baseName) {
                case "bool": case "byte": case "i8": case "i16":
                case "i32": case "i64": case "double":
                    return true;
                case "string": case "binary": case "uuid":
                    return false;
                default:
                    return false;
            }
        }
        return false;
    }

    /**
     * Determine if a struct needs isset tracking and what type
     */
    private IssetType needsIsset(StructLikeNode struct) {
        int count = 0;
        for (FieldNode field : struct.getFields()) {
            TypeNode fieldType = field.getType(); // Use original type
            // Remove "yy" hack for needsIsset calculation
            // if (getEffectiveFieldName(field.getName()).equals("y") && field.getName().equals("yy")) {
            //      fieldType = new BaseTypeNode(BaseTypeNode.BaseTypeEnum.DOUBLE);
            // }
            if (!typeCanBeNull(fieldType)) {
                count++;
            }
        }
        if (count == 0) return IssetType.NONE;
        if (count <= 64) return IssetType.PRIMITIVE;
        return IssetType.BITSET;
    }

    /**
     * Determine the appropriate primitive type for isset tracking
     */
    private String determinePrimitiveType(int count) {
        if (count <= 8) return "byte";
        if (count <= 16) return "short";
        if (count <= 32) return "int";
        if (count <= 64) return "long";
        return "long";
    }

    /**
     * Convert a Thrift type to a Java enum string
     */
    private String typeToEnum(TypeNode type) {
        TypeNode trueType = getTrueType(type);

        // Remove "yy" hack for typeToEnum
        // if (type instanceof BaseTypeNode && type.getName().equals("double") &&
        //     structLikeNode != null && structLikeNode.getFields().stream().anyMatch(f -> f.getName().equals("yy") && f.getType() instanceof MapTypeNode) ) {
        //      boolean isOriginalYyMap = false;
        //      for(FieldNode f : structLikeNode.getFields()){
        //          if(f.getName().equals("yy") && f.getType().isMap()){
        //              isOriginalYyMap = true;
        //              break;
        //          }
        //      }
        //      if(isOriginalYyMap) return "org.apache.thrift.protocol.TType.DOUBLE";
        // }

        if (trueType.isBaseType()) {
            String baseName = trueType.getName();
            if (trueType.isBinary() || "binary".equals(baseName)) {
                return "org.apache.thrift.protocol.TType.STRING";
            }
            switch (baseName) {
                case "void": return "org.apache.thrift.protocol.TType.VOID";
                case "string": return "org.apache.thrift.protocol.TType.STRING";
                case "bool": return "org.apache.thrift.protocol.TType.BOOL";
                case "byte": // Fallthrough
                case "i8": return "org.apache.thrift.protocol.TType.BYTE";
                case "i16": return "org.apache.thrift.protocol.TType.I16";
                case "i32": return "org.apache.thrift.protocol.TType.I32";
                case "i64": return "org.apache.thrift.protocol.TType.I64";
                case "uuid": return "org.apache.thrift.protocol.TType.UUID";
                case "double": return "org.apache.thrift.protocol.TType.DOUBLE";
                default:
                    // Check if it's "byte" due to BaseTypeEnum.BYTE representation if different from "i8"
                    if (trueType instanceof BaseTypeNode && ((BaseTypeNode)trueType).getType() == BaseTypeNode.BaseTypeEnum.BYTE) {
                        return "org.apache.thrift.protocol.TType.BYTE";
                    }
                    throw new RuntimeException("Unknown base type for TType enum: " + baseName);
            }
        } else if (trueType.isEnum()) {
            return "org.apache.thrift.protocol.TType.I32";
        } else if (trueType.isStruct() || trueType.isException()) {
            return "org.apache.thrift.protocol.TType.STRUCT";
        } else if (trueType.isMap()) {
            return "org.apache.thrift.protocol.TType.MAP";
        } else if (trueType.isSet()) {
            return "org.apache.thrift.protocol.TType.SET";
        } else if (trueType.isList()) {
            return "org.apache.thrift.protocol.TType.LIST";
        }
        throw new RuntimeException("Unknown type for TType enum: " + trueType.getName());
    }

    // Remove getEffectiveFieldTypeHelper as it was primarily for the "yy" hack
    // private TypeNode getEffectiveFieldTypeHelper(StructLikeNode currentStruct, String fieldName) {
    //     for (FieldNode f : currentStruct.getFields()) {
    //         if (f.getName().equals(fieldName)) {
    //             // if (fieldName.equals("yy")) return new BaseTypeNode(BaseTypeNode.BaseTypeEnum.DOUBLE); // Removed hack
    //             return f.getType();
    //         }
    //     }
    //     return null;
    // }


    /**
     * Check if a struct has the 'final' annotation
     */
    private boolean isFinal(StructLikeNode struct) {
        for (TypeAnnotationNode annotation : struct.getAnnotations()) {
            if (annotation.getName().equals("final")) {
                return true;
            }
        }
        return false;
    }

    /**
     * Check if a struct or field is deprecated
     */
    private boolean isDeprecated(Object obj) {
        if (obj instanceof StructLikeNode) {
            for (TypeAnnotationNode annotation : ((StructLikeNode) obj).getAnnotations()) {
                if (annotation.getName().equals("deprecated")) {
                    return true;
                }
            }
        } else if (obj instanceof FieldNode) {
            // FieldNode itself doesn't store annotations directly in the provided AST.
            // Assuming annotations might be on field.getType().getAnnotations() or similar if needed.
            // For now, this won't find field deprecations based on current FieldNode.
        }
        return false;
    }

    /**
     * Make a valid Java identifier from a string
     */
    private String makeValidJavaIdentifier(String fromName) {
        String str = fromName;
        if (str.isEmpty()) {
            return str;
        }

        char c = str.charAt(0);
        if (Character.isDigit(c)) {
            str = "_" + str;
        }

        StringBuilder result = new StringBuilder();
        for (int i = 0; i < str.length(); i++) {
            c = str.charAt(i);
            if (Character.isLetterOrDigit(c) || c == '_') {
                result.append(c);
            } else {
                result.append('_');
            }
        }

        return normalizeName(result.toString());
    }

    /**
     * Normalize a name (handle Java keywords)
     */
    private String normalizeName(String name) {
        String[] keywords = {
                "abstract", "assert", "boolean", "break", "byte", "case", "catch", "char", "class", "const", "continue",
                "default", "do", "double", "else", "enum", "extends", "final", "finally", "float", "for", "goto", "if",
                "implements", "import", "instanceof", "int", "interface", "long", "native", "new", "package", "private",
                "protected", "public", "return", "short", "static", "strictfp", "super", "switch", "synchronized", "this",
                "throw", "throws", "transient", "try", "void", "volatile", "while", "true", "false", "null"
        };
        for (String keyword : keywords) {
            if (name.equals(keyword)) {
                return "$" + name;
            }
        }
        return name;
    }

    private String declareField(FieldNode field, boolean init, boolean comment) {
        StringBuilder result = new StringBuilder();
        TypeNode fieldType = field.getType(); // Use original type
        String originalFieldName = field.getName(); // Use original name

        TypeNode type = getTrueType(fieldType);

        if (typeCanBeNull(type)) {
            result.append(javaNullableAnnotation()).append(" ");
        }

        result.append(getTypeName(type, false, init, false, false))
                .append(" ")
                .append(originalFieldName); // Use original name

        if (init) {
            // Default value logic
            if (type.isBaseType() && field.getDefaultValue() != null) {
                result.append(" = /* TODO: render default value for base type */");
            } else if (type.isBaseType()) {
                String baseName = type.getName();
                if (type.isBinary()) baseName = "binary";

                switch (baseName) {
                    case "void": break;
                    case "string": case "uuid": case "binary": result.append(" = null"); break;
                    case "bool": result.append(" = false"); break;
                    case "byte": case "i8": case "short": case "i16":
                    case "int": case "i32": case "long": case "i64":
                        result.append(" = 0"); break;
                    case "double": result.append(" = 0.0"); break;
                    default: result.append(" = /* TODO: unknown base type default */"); break;
                }
            } else if (type.isEnum()) {
                result.append(" = null");
            } else if (type.isContainer()) {
                String typeNameWithOptions = getTypeName(type, false, true, false, false);
                String classForEnumMapSet = "";
                if (type.isMap() && getTrueType(type.getChildNodes().get(0)).isEnum() && !sortedContainers) {
                    classForEnumMapSet = getTypeName(getTrueType(type.getChildNodes().get(0)), true, false, true, true);
                    result.append(" = new ").append(typeNameWithOptions).append("(").append(classForEnumMapSet).append(")");
                } else if (type.isSet() && getTrueType(type.getChildNodes().get(0)).isEnum() && !sortedContainers) {
                    classForEnumMapSet = getTypeName(getTrueType(type.getChildNodes().get(0)), true, false, true, true);
                    result.append(" = java.util.EnumSet.noneOf(").append(classForEnumMapSet).append(")");
                } else {
                    result.append(" = new ").append(typeNameWithOptions).append("()");
                }
            } else if (type.isStruct() || type.isException()) {
                result.append(" = new ").append(getTypeName(type, false, true, false, false)).append("()");
            } else {
                result.append(" = /* TODO: Unhandled type for init */");
            }
        }

        result.append(";");

        if (comment) {
            result.append(" // ");
            if (field.getRequirement() == FieldNode.Requirement.OPTIONAL) {
                result.append("optional");
            } else if (field.getRequirement() == FieldNode.Requirement.REQUIRED) {
                result.append("required");
            } else {
                result.append("default");
            }
        }
        return result.toString();
    }

    private String getTypeName(TypeNode type) {
        return getTypeName(type, false, false, false, false);
    }

    private String getTypeName(TypeNode type, boolean in_container, boolean in_init, boolean as_args, boolean force_namespace) {
        TypeNode trueType = getTrueType(type);
        String prefix = "";

        if (trueType.isBaseType()) {
            String baseName = trueType.getName();
            if (trueType.isBinary()) baseName = "binary"; // Normalize for consistent switch

            switch (baseName) {
                case "void": return in_container ? "Void" : "void";
                case "string": return "java.lang.String";
                case "binary": return "java.nio.ByteBuffer";
                case "uuid": return "java.util.UUID";
                case "bool": return in_container ? "java.lang.Boolean" : "boolean";
                case "byte": case "i8": return in_container ? "java.lang.Byte" : "byte";
                case "i16": return in_container ? "java.lang.Short" : "short";
                case "i32": return in_container ? "java.lang.Integer" : "int";
                case "i64": return in_container ? "java.lang.Long" : "long";
                case "double": return in_container ? "java.lang.Double" : "double";
                default: throw new RuntimeException("Unknown base type: " + baseName);
            }
        } else if (trueType.isContainer()) {
            String generics = "";
            if (!as_args) {
                if (trueType.isMap()) {
                    TypeNode keyType = trueType.getChildNodes().get(0);
                    TypeNode valueType = trueType.getChildNodes().get(1);
                    generics = "<" + getTypeName(keyType, true, false, false, true) + ", "
                            + getTypeName(valueType, true, false, false, true) + ">";
                } else if (trueType.isList() || trueType.isSet()) {
                    TypeNode elemType = trueType.getChildNodes().get(0);
                    generics = "<" + getTypeName(elemType, true, false, false, true) + ">";
                }
            }

            if (trueType.isMap()) {
                if (in_init) {
                    if (!sortedContainers && getTrueType(trueType.getChildNodes().get(0)).isEnum()) {
                        prefix = "java.util.EnumMap";
                    } else if (sortedContainers) {
                        prefix = "java.util.TreeMap";
                    } else {
                        prefix = "java.util.HashMap";
                    }
                } else {
                    prefix = "java.util.Map";
                }
                return prefix + generics;
            } else if (trueType.isSet()) {
                if (in_init) {
                    if (!sortedContainers && getTrueType(trueType.getChildNodes().get(0)).isEnum()) {
                        prefix = "java.util.EnumSet";
                    } else if (sortedContainers) {
                        prefix = "java.util.TreeSet";
                    } else {
                        prefix = "java.util.HashSet";
                    }
                } else {
                    prefix = "java.util.Set";
                }
                return prefix + generics;
            } else if (trueType.isList()) {
                prefix = in_init ? "java.util.ArrayList" : "java.util.List";
                return prefix + generics;
            }
        } else if (trueType.isStruct() || trueType.isException() || trueType.isEnum()) {
            String typeName = makeValidJavaIdentifier(trueType.getName());
            if (force_namespace) {
                if (!typeName.contains(".") && this.packageName != null && !this.packageName.isEmpty()) {
                    typeName = this.packageName + "." + typeName;
                }
            }

            if (as_args && (trueType.isStruct() || trueType.isException() || trueType.isEnum())) {
                return typeName + ".class";
            }
            return typeName;
        }
        return makeValidJavaIdentifier(trueType.getName());
    }

    private TypeNode getTrueType(TypeNode type) {
        // In a more complete system, this would resolve TypedefNode
        return type;
    }

    private String indent() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < indentLevel; i++) {
            sb.append("  ");
        }
        return sb.toString();
    }

    private enum IssetType {
        NONE,
        PRIMITIVE,
        BITSET
    }
}
