package com.github.decster.gen;

import com.github.decster.ast.EnumNode;
import com.github.decster.ast.EnumValueNode;
import java.util.List;
import org.apache.thrift.TEnum;
import org.apache.thrift.annotation.Nullable;


public class EnumGenerator {
    private final EnumNode enumNode;
    private final String packageName;
    private final String date;

    public EnumGenerator(EnumNode enumNode, String packageName, String date) {
        this.enumNode = enumNode;
        this.packageName = packageName;
        this.date = date;
    }

    public String generate() {
        StringBuilder sb = new StringBuilder();
        String enumName = enumNode.getName();

        // Package declaration
        sb.append("package ").append(packageName).append(";\n\n");

        // Imports
        sb.append("import org.apache.thrift.TEnum;\n");
        sb.append("import org.apache.thrift.annotation.Nullable;\n\n");

        // TODO: Add class-level Javadoc here if enumNode.getDocString() becomes available

        // @Generated annotation
        sb.append("@javax.annotation.Generated(value = \"Autogenerated by Thrift Compiler (0.20.0)\", date = \"").append(date).append("\")\n");

        // Enum declaration
        sb.append("public enum ").append(enumName).append(" implements TEnum {\n");

        // Enum values
        List<EnumValueNode> values = enumNode.getValues();
        int nextValue = 0;
        for (int i = 0; i < values.size(); i++) {
            EnumValueNode enumValueNode = values.get(i);
            String valueName = enumValueNode.getName();
            Integer explicitValue = enumValueNode.getValue();

            int actualValue;
            if (explicitValue != null) {
                actualValue = explicitValue;
                nextValue = actualValue + 1;
            } else {
                actualValue = nextValue;
                nextValue++;
            }

            sb.append("  ").append(valueName).append("(").append(actualValue).append(")");
            if (i < values.size() - 1) {
                sb.append(",\n");
            } else {
                sb.append(";\n\n");
            }
        }

        // Private final int value field
        sb.append("  private final int value;\n\n");

        // Constructor
        sb.append("  private ").append(enumName).append("(int value) {\n");
        sb.append("    this.value = value;\n");
        sb.append("  }\n\n");

        // getValue() method
        sb.append("  @Override\n");
        sb.append("  public int getValue() {\n");
        sb.append("    return value;\n");
        sb.append("  }\n\n");

        // findByValue() method
        sb.append("  @Nullable\n");
        sb.append("  public static ").append(enumName).append(" findByValue(int value) {\n");
        sb.append("    switch (value) {\n");
        for (EnumValueNode enumValueNode : values) {
            // Need to re-calculate actualValue or store it from the previous loop
            // For simplicity, let's assume getValues() provides them in order and we can re-infer or store.
            // Re-inferring for now, but this is not ideal.
            // A better approach would be to store the actual values when first processing them.
            // For this subtask, let's re-evaluate, assuming values are processed in order for findByValue generation.
            // This part requires that the implicit value assignment logic is consistent.
        }

        // Re-iterate to get actual values for the switch cases
        nextValue = 0; // Reset for switch case generation
        for (EnumValueNode enumValueNode : values) {
            String valueName = enumValueNode.getName();
            Integer explicitValue = enumValueNode.getValue();
            int actualValue;
            if (explicitValue != null) {
                actualValue = explicitValue;
                nextValue = actualValue + 1;
            } else {
                actualValue = nextValue;
                nextValue++;
            }
            sb.append("      case ").append(actualValue).append(":\n");
            sb.append("        return ").append(valueName).append(";\n");
        }
        sb.append("      default:\n");
        sb.append("        return null;\n");
        sb.append("    }\n");
        sb.append("  }\n");

        sb.append("}\n");

        return sb.toString();
    }
}
