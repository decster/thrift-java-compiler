package com.github.decster.gen;

import com.github.decster.ast.EnumNode;
import com.github.decster.ast.EnumValueNode;

import java.util.List;
import java.util.Map;
import java.util.HashMap;
// No longer assuming org.apache.thrift.annotation.Nullable for generated code directly here,
// but findByValue itself should be annotated if that's the desired Thrift standard.
// Standard Thrift enums do have @org.apache.thrift.annotation.Nullable on findByValue.

public class EnumGenerator {
    private final EnumNode enumNode;
    private final String packageName;
    private final String date;

    public EnumGenerator(EnumNode enumNode, String packageName, String date) {
        this.enumNode = enumNode;
        this.packageName = packageName;
        this.date = date;
    }

    public String generate() {
        StringBuilder sb = new StringBuilder();
        String enumName = enumNode.getName();

        // Package declaration
        sb.append("package ").append(packageName).append(";\n\n");

        // Imports
        sb.append("import org.apache.thrift.TEnum;\n");
        // Only add Nullable if actually used, standard Thrift does use it for findByValue
        // For now, let's assume it's generally useful.
        sb.append("import org.apache.thrift.annotation.Nullable;\n\n");


        // Class-level Javadoc - REMOVED as EnumNode does not have getDocString()
        // String docString = enumNode.getDocString();
        // if (docString != null && !docString.isEmpty()) {
        //     sb.append("/**\n");
        //     for (String line : docString.split("\n")) {
        //         sb.append(" * ").append(line.replace("*/", "* /")).append("\n");
        //     }
        //     sb.append(" */\n");
        // }

        // @Generated annotation
        sb.append("@javax.annotation.Generated(value = \"Autogenerated by Thrift Compiler (0.20.0)\", date = \"").append(date).append("\")\n");

        // Enum declaration
        sb.append("public enum ").append(enumName).append(" implements TEnum {\n");

        // Enum values
        List<EnumValueNode> values = enumNode.getValues();
        Map<EnumValueNode, Integer> enumActualValues = new HashMap<>();
        int nextValue = 0;

        for (int i = 0; i < values.size(); i++) {
            EnumValueNode enumValueNode = values.get(i);
            String valueName = enumValueNode.getName();
            Integer explicitValue = enumValueNode.getValue(); // This is the correct method from EnumValueNode.java

            int actualValue;
            if (explicitValue != null) {
                actualValue = explicitValue;
                nextValue = actualValue + 1;
            } else {
                actualValue = nextValue;
                nextValue++;
            }
            enumActualValues.put(enumValueNode, actualValue);

            sb.append("  ").append(valueName).append("(").append(actualValue).append(")");
            if (i < values.size() - 1) {
                sb.append(",\n");
            } else {
                sb.append(";\n\n");
            }
        }

        // Private final int value field
        sb.append("  private final int value;\n\n");

        // Constructor
        sb.append("  private ").append(enumName).append("(int value) {\n");
        sb.append("    this.value = value;\n");
        sb.append("  }\n\n");

        // getValue() method
        sb.append("  @Override\n"); // TEnum interface method
        sb.append("  public int getValue() {\n");
        sb.append("    return value;\n");
        sb.append("  }\n\n");

        // findByValue() method
        sb.append("  @Nullable\n");
        sb.append("  public static ").append(enumName).append(" findByValue(int value) {\n");
        sb.append("    switch (value) {\n");
        for (EnumValueNode enumValueNode : values) {
            String valueName = enumValueNode.getName();
            Integer storedActualValue = enumActualValues.get(enumValueNode);

            // This check is mostly for robustness during development;
            // if enumActualValues is populated correctly, storedActualValue should not be null.
            if (storedActualValue == null) {
                 // This indicates an internal error in generator logic or map population
                sb.append("      // Internal Generator Error: Actual value not found for ").append(valueName).append("\n");
                continue;
            }
            sb.append("      case ").append(storedActualValue).append(":\n");
            sb.append("        return ").append(valueName).append(";\n");
        }
        sb.append("      default:\n");
        sb.append("        return null;\n");
        sb.append("    }\n");
        sb.append("  }\n");

        sb.append("}\n");

        return sb.toString();
    }
}
