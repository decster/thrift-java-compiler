package com.github.decster.gen;

import com.github.decster.ast.BaseTypeNode; // Changed from BaseTypeEnum
import com.github.decster.ast.FieldNode;
import com.github.decster.ast.FunctionNode;
import com.github.decster.ast.IdentifierTypeNode;
import com.github.decster.ast.ServiceNode;
// It's often better to import specific stub classes if not all are needed or to avoid name clashes.
// Fixed import to use package wildcard instead of non-existent class AstTestStubs
import com.github.decster.gen.*;


import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.BeforeEach;

// Removed java.util.List, ArrayList, Collections as they are likely encapsulated in Stubs or not directly used.
// Re-add if specific direct usages are found later.

// Static imports for JUnit assertions are kept by GeneratorTestUtil, so direct ones here can be removed if not used.
// For now, keep them if methods like assertTrue/assertFalse are called directly in this file,
// otherwise, they will be removed if all such calls are through GeneratorTestUtil.
// import static org.junit.jupiter.api.Assertions.assertTrue; // Now in GeneratorTestUtil
// import static org.junit.jupiter.api.Assertions.assertFalse; // Now in GeneratorTestUtil
import static com.github.decster.gen.GeneratorTestUtil.*;


public class ServiceGeneratorTest {

    private ServiceGenerator generator;
    private StubServiceNode serviceNode; // Assuming StubServiceNode is from AstTestStubs
    private static final String TEST_PACKAGE = "com.test.services";
    private static final String TEST_DATE = "2023-10-27";

    // assertContains, 간단히하기, 调试上下文 moved to GeneratorTestUtil

    @BeforeEach
    void setUp() {
        // Default setup, can be overridden by tests
    }

    @Test
    void testSimpleService() {
        serviceNode = new StubServiceNode("Calculator");

        StubFunctionNode pingFunc = new StubFunctionNode("ping", new StubBaseTypeNode(BaseTypeNode.BaseTypeEnum.VOID), false);
        pingFunc.setDocString("A simple ping function.");
        serviceNode.addFunction(pingFunc);

        StubFunctionNode addFunc = new StubFunctionNode("add", new StubBaseTypeNode(BaseTypeNode.BaseTypeEnum.I32), false);
        addFunc.addParameter(new StubFieldNode((short)1, "num1", new StubBaseTypeNode(BaseTypeNode.BaseTypeEnum.I32)));
        addFunc.addParameter(new StubFieldNode((short)2, "num2", new StubBaseTypeNode(BaseTypeNode.BaseTypeEnum.I32)));
        serviceNode.addFunction(addFunc);

        StubDocumentNode docNode = new StubDocumentNode();
        generator = new ServiceGenerator(serviceNode, docNode, TEST_PACKAGE, TEST_DATE);
        String code = generator.generate();

        assertContains(code, "public class Calculator {");
        assertContains(code, "package " + TEST_PACKAGE + ";");
        assertContains(code, "@javax.annotation.Generated(value = \"Autogenerated by Thrift Compiler (0.20.0)\", date = \"" + TEST_DATE + "\")");

        // Iface
        assertContains(code, "public interface Iface {");
        assertContains(code, "    /**\n     * A simple ping function.\n     */");
        assertContains(code, "public void ping() throws org.apache.thrift.TException;");
        assertContains(code, "public int add(int num1, int num2) throws org.apache.thrift.TException;");

        // AsyncIface
        assertContains(code, "public interface AsyncIface {");
        assertContains(code, "public void ping(org.apache.thrift.async.AsyncMethodCallback<java.lang.Void> resultHandler) throws org.apache.thrift.TException;");
        assertContains(code, "public void add(int num1, int num2, org.apache.thrift.async.AsyncMethodCallback<java.lang.Integer> resultHandler) throws org.apache.thrift.TException;");

        // Client
        assertContains(code, "public static class Client extends org.apache.thrift.TServiceClient implements Iface {");
        assertContains(code, "public void send_ping() throws org.apache.thrift.TException {");
        assertContains(code, "sendBase(\"ping\", args, TMessageType.CALL);");
        assertContains(code, "public void recv_ping() throws org.apache.thrift.TException {");
        assertContains(code, "public int add(int num1, int num2) throws org.apache.thrift.TException {");
        assertContains(code, "send_add(num1, num2);");
        assertContains(code, "return recv_add();");

        // AsyncClient
        assertContains(code, "public static class AsyncClient extends org.apache.thrift.async.TAsyncClient implements AsyncIface {");
        assertContains(code, "public static class ping_call extends org.apache.thrift.async.TAsyncMethodCall<java.lang.Void> {");
        assertContains(code, "public static class add_call extends org.apache.thrift.async.TAsyncMethodCall<java.lang.Integer> {");

        // Processor
        assertContains(code, "public static class Processor<I extends Iface> extends org.apache.thrift.TBaseProcessor implements org.apache.thrift.TProcessor {");
        assertContains(code, "processMap.put(\"ping\", new ping());");
        assertContains(code, "processMap.put(\"add\", new add());");
        assertContains(code, "public static class ping<I extends Iface> extends org.apache.thrift.ProcessFunction<I, ping_args> {");
        assertContains(code, "public static class add<I extends Iface> extends org.apache.thrift.ProcessFunction<I, add_args> {");

        // Args and Results
        assertContains(code, "public static class ping_args implements TBase<ping_args, ping_args._Fields>");
        assertContains(code, "public static class ping_result implements TBase<ping_result, ping_result._Fields>");
        assertContains(code, "public static class add_args implements TBase<add_args, add_args._Fields>");
        assertContains(code, "public int num1;");
        assertContains(code, "public int num2;");
        assertContains(code, "public static class add_result implements TBase<add_result, add_result._Fields>");
        assertContains(code, "public int success;");

        // Imports
        assertContains(code, "import java.util.List;");
        assertContains(code, "import org.apache.thrift.async.AsyncMethodCallback;");
    }

    @Test
    void testServiceWithExceptions() {
        serviceNode = new StubServiceNode("ErrService");
        StubFunctionNode errFunc = new StubFunctionNode("doOrThrow", new StubBaseTypeNode(BaseTypeNode.BaseTypeEnum.STRING), false);
        errFunc.addParameter(new StubFieldNode((short)1, "input", new StubBaseTypeNode(BaseTypeNode.BaseTypeEnum.STRING)));
        // Assume MyException is a struct defined elsewhere
        errFunc.addException(new StubFieldNode((short)1, "ex1", new StubIdentifierTypeNode("com.test.exceptions.MyException")));
        serviceNode.addFunction(errFunc);

        StubDocumentNode docNode = new StubDocumentNode();
        StubStructNode myExceptionStruct = new StubStructNode("com.test.exceptions.MyException");
        docNode.addDefinition(myExceptionStruct);
        generator = new ServiceGenerator(serviceNode, docNode, "com.test.svc", "2023-01-01");
        String code = generator.generate();

        assertContains(code, "public interface Iface {");
        assertContains(code, "public java.lang.String doOrThrow(java.lang.String input) throws com.test.exceptions.MyException, org.apache.thrift.TException;");

        assertContains(code, "public interface AsyncIface {");
        assertContains(code, "public void doOrThrow(java.lang.String input, org.apache.thrift.async.AsyncMethodCallback<java.lang.String> resultHandler) throws org.apache.thrift.TException;");

        assertContains(code, "public java.lang.String recv_doOrThrow() throws com.test.exceptions.MyException, org.apache.thrift.TException {");
        assertContains(code, "if (result.ex1 != null) {");
        assertContains(code, "throw result.ex1;");

        assertContains(code, "public static class doOrThrow_result implements TBase<doOrThrow_result, doOrThrow_result._Fields>");
        assertContains(code, "public java.lang.String success;");
        assertContains(code, "public com.test.exceptions.MyException ex1;");
        assertContains(code, "tmpMap.put(_Fields.EX1, new FieldMetaData(\"ex1\", TFieldRequirementType.OPTIONAL, new StructMetaData(TType.STRUCT, com.test.exceptions.MyException.class)));");
        assertContains(code, "import com.test.exceptions.MyException;");
    }

    @Test
    void testServiceExtends() {
        serviceNode = new StubServiceNode("ChildService");
        serviceNode.setExtendsService("com.test.parent.ParentService"); // Changed to String
        StubFunctionNode childFunc = new StubFunctionNode("childAction", new StubBaseTypeNode(BaseTypeNode.BaseTypeEnum.BOOL), false);
        serviceNode.addFunction(childFunc);

        StubDocumentNode docNode = new StubDocumentNode();
        StubServiceNode parentService = new StubServiceNode("com.test.parent.ParentService");
        docNode.addDefinition(parentService);
        generator = new ServiceGenerator(serviceNode, docNode, TEST_PACKAGE, TEST_DATE);
        String code = generator.generate();

        assertContains(code, "public interface Iface extends com.test.parent.ParentService.Iface {");
        assertContains(code, "public interface AsyncIface extends com.test.parent.ParentService.AsyncIface {");
        assertContains(code, "public static class Client extends com.test.parent.ParentService.Client implements Iface {");
        assertContains(code, "public static class AsyncClient extends com.test.parent.ParentService.AsyncClient implements AsyncIface {");
        assertContains(code, "public static class Processor<I extends Iface> extends com.test.parent.ParentService.Processor implements org.apache.thrift.TProcessor {");
        assertContains(code, "super(iface, getProcessMap(new HashMap<String, org.apache.thrift.ProcessFunction<I, ? extends TBase>>()));"); // Processor constructor
        assertContains(code, "import com.test.parent.ParentService;");
    }

    @Test
    void testServiceWithVariousTypes() {
        serviceNode = new StubServiceNode("ComplexTypeService");
        StubFunctionNode func = new StubFunctionNode("processComplex", new StubMapTypeNode(new StubBaseTypeNode(BaseTypeNode.BaseTypeEnum.STRING), new StubIdentifierTypeNode("com.custom.MyStruct")), false);
        func.addParameter(new StubFieldNode((short)1, "pListOfInts", new StubListTypeNode(new StubBaseTypeNode(BaseTypeNode.BaseTypeEnum.I32))));
        func.addParameter(new StubFieldNode((short)2, "pSetOfStrings", new StubSetTypeNode(new StubBaseTypeNode(BaseTypeNode.BaseTypeEnum.STRING))));
        func.addParameter(new StubFieldNode((short)3, "pMyEnum", new StubIdentifierTypeNode("com.custom.MyEnum", true)));
        serviceNode.addFunction(func);

        StubDocumentNode docNode = new StubDocumentNode();
        StubStructNode myStruct = new StubStructNode("com.custom.MyStruct");
        docNode.addDefinition(myStruct);
        StubEnumNode myEnum = new StubEnumNode("com.custom.MyEnum");
        docNode.addDefinition(myEnum);
        generator = new ServiceGenerator(serviceNode, docNode, TEST_PACKAGE, TEST_DATE);
        String code = generator.generate();

        // Iface
        assertContains(code, "public java.util.Map<java.lang.String, com.custom.MyStruct> processComplex(java.util.List<java.lang.Integer> pListOfInts, java.util.Set<java.lang.String> pSetOfStrings, com.custom.MyEnum pMyEnum) throws org.apache.thrift.TException;");
        // AsyncIface
        assertContains(code, "public void processComplex(java.util.List<java.lang.Integer> pListOfInts, java.util.Set<java.lang.String> pSetOfStrings, com.custom.MyEnum pMyEnum, org.apache.thrift.async.AsyncMethodCallback<java.util.Map<java.lang.String, com.custom.MyStruct>> resultHandler) throws org.apache.thrift.TException;");

        // Args struct fields
        assertContains(code, "public static class processComplex_args implements TBase<processComplex_args, processComplex_args._Fields>");
        assertContains(code, "public java.util.List<java.lang.Integer> pListOfInts;");
        assertContains(code, "public java.util.Set<java.lang.String> pSetOfStrings;");
        assertContains(code, "public com.custom.MyEnum pMyEnum;");

        // Args MetaData
        assertContains(code, "new ListMetaData(TType.LIST, new FieldValueMetaData(TType.I32))");
        assertContains(code, "new SetMetaData(TType.SET, new FieldValueMetaData(TType.STRING))");
        assertContains(code, "new EnumMetaData(TType.ENUM, com.custom.MyEnum.class)");

        // Result struct field
        assertContains(code, "public static class processComplex_result implements TBase<processComplex_result, processComplex_result._Fields>");
        assertContains(code, "public java.util.Map<java.lang.String, com.custom.MyStruct> success;");
        // Result MetaData
        assertContains(code, "new MapMetaData(TType.MAP, new FieldValueMetaData(TType.STRING), new StructMetaData(TType.STRUCT, com.custom.MyStruct.class))");

        assertContains(code, "import com.custom.MyStruct;");
        assertContains(code, "import com.custom.MyEnum;");
        assertContains(code, "import java.util.Set;"); // From pSetOfStrings
    }

    @Test
    void testOnewayFunction() {
        serviceNode = new StubServiceNode("OnewayTestService");
        StubFunctionNode onewayFunc = new StubFunctionNode("logMessage", new StubBaseTypeNode(BaseTypeNode.BaseTypeEnum.VOID), true); // oneway = true
        onewayFunc.addParameter(new StubFieldNode((short)1, "message", new StubBaseTypeNode(BaseTypeNode.BaseTypeEnum.STRING)));
        serviceNode.addFunction(onewayFunc);

        StubDocumentNode docNode = new StubDocumentNode();
        generator = new ServiceGenerator(serviceNode, docNode, TEST_PACKAGE, TEST_DATE);
        String code = generator.generate();

        // Iface: oneway still has TException because client send can fail
        assertContains(code, "public void logMessage(java.lang.String message) throws org.apache.thrift.TException;");
        // AsyncIface: still has TException
        assertContains(code, "public void logMessage(java.lang.String message, org.apache.thrift.async.AsyncMethodCallback<java.lang.Void> resultHandler) throws org.apache.thrift.TException;");

        // Client: No recv_logMessage() call
        assertContains(code, "public void logMessage(java.lang.String message) throws org.apache.thrift.TException {\n" +
                                 "      send_logMessage(message);\n" +
                                 "    }");
        assertNotContains(code, "recv_logMessage();");

        // AsyncClient _call class for oneway
        assertContains(code, "public static class logMessage_call extends org.apache.thrift.async.TAsyncMethodCall<java.lang.Void> {");
        assertContains(code, "super(client, protocolFactory, transport, resultHandler, true);"); // last arg isOneway = true

        // Processor: isOneway() should be true
        assertContains(code, "public static class logMessage<I extends Iface> extends org.apache.thrift.ProcessFunction<I, logMessage_args> {");
        assertContains(code, "protected boolean isOneway() {\n        return true;\n      }");
        // Processor: getResult should not attempt to write for oneway if there was an application error (though this part is tricky)
        // For now, we primarily check the isOneway flag.
    }
}
